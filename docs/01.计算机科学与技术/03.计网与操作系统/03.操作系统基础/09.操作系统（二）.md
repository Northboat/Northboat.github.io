---
title: 操作系统（二）
date: 2024-3-7
permalink: /pages/e55f25/
author: 
  name: Arkrypto
  link: https://github.com/Arkrypto
---

## 处理机管理

### 操作系统概述

操作系统特征

- 并发性
- 共享性
- 虚拟性
- 异步性

操作系统历程：原始操作系统 ——> 管理系统 ——> 操作系统

不同操作系统

- 批处理系统：关注吞吐量
- 分时：关注交互性
- 实时：关注及时响应（通过中断机制）

分时系统得特征

- 同时性，又叫多路性
- 独立性
- 交互性
- 及时性（注意和实时性区别）

微内核和宏内核：微内核的效率更低，因为需要频繁切换状态（内核态和用户态）

重定位：地址转换机构、链接装入过程

- 静态地址重定位：在程序装入时进行地址重定位
- 动态地址重定位：在程序执行时定位，即边执行边定位

三级调度

- 作业调度，又叫高级调度：决定运行哪个程序，注意是程序
- 内存调度，又叫中级调度：决定是否将进程调入内存
- 处理机/CPU调度，又叫低级调度：决定将 CPU 分配给哪个进程

多道程序处理：利用了处理器和通道并行工作的能力

中断分类

- 硬件中断：外部中断、终止异常
- 软件中断：自陷异常、故障异常
- 外部中断：可屏蔽中断、不可屏蔽中断
- 内部中断：终止异常、自陷异常、故障异常

访管中断属于软中断/内中断，I/O 中断属于外中断

用户态、内核态的转换和逻辑地址、物理地址的转换都是**由硬件完成**的，中断处理也必须需要硬件参与

### 作业管理和用户接口

系统调用，中断

作业的调度算法

- 先来先：FCFS
- 短作业优先：SJF
- 相应比高者优先：相应比 = 已等待时间 / 所需 CPU 时间

SPOOLing 系统

- 输入输出缓存区
- 输入输出井

### 进程调度

进程状态：创建、就绪、阻塞、执行、终止

- 其中就绪、阻塞、执行是三种基本状态

进程控制块：PCB

- 进程由 PCB、数据、以及代码三部分组成

进程是资源分配的基本单位，线程是资源调度的基本单位

进程调度算法

- 先来先服务：FCFS
- 最短 CPU 运行期优先：SCBF
- 最高优先权：HPF，分为静态和动态、抢占式和非抢占式
- 时间片轮转：RR
- 多级反馈队列：MFQS

注意对于未明确抢占的系统，默认为非抢占式，即一个进程开始进行，将占有这个资源直到其执行结束，即使有优先级更高的进程进入就绪队列，依旧保持执行

周转时间：进程终止时间 - 进程调入时间

- 衡量处理效率的两个重要数据：周转时间、平均周转时间

周转时间的计算：甘特图

- 一定注意对于周转时间，后面的进程等待的时间是叠加的，叠加的除了前面进程的执行时间，还有切换进程的时间（如前面切换了3次，则周转时间要加上三次切换的时间，而不是单独计算）
- 画出完整的甘特图再分析是最为稳妥的

线程：轻量级进程

- 线程不共享：注册
- 用户级线程和内核级线程：后者需要进入内核态，前者不需要

线程与进程的区别

- 资源和地址方面
- 调度代价方面

### 同步与互斥

临界区：一段互斥执行**程序**，程序，是程序

- 进程处于临界区，意味着进程当前占有处理机
- 临界区共享资源的占有和处理机的调度并不是很有关系，就是说即使进程处于临界区，仍可以被抢夺处理机（感觉是中级调度和低级调度的区别）

当 5 个进程共享一类临界资源时，共有 5 个临界区（5 个进程都有一段互斥的代码，即临界区）

任意时刻可以共享的代码（纯代码、可重入代码）：就相当于 utils 包，是不可修改的代码

同步互斥的规则：空闲让进、忙则等待、有限等待、让权等待

信号量机制，P/V 操作，同步互斥设计

- 互斥是进程间的直接约束
- 同步是间接约束

P/V 操作是一种低级通信原语（不可分割的指令序列），是一段不可中断的过程

P/V 操作和 wait/signal 的区别

- P(S) 操作时，要根据信号量 S 的值来确定是等待还是进入；而 S.wait() 操作直接就是让进程 S 阻塞，直到有进程唤醒他才进入就绪队列（等待和阻塞似乎不太一样）
- V(S) 操作表示释放一个资源；signal(S) 表示令阻塞的 S 进程进入**就绪**状态

注意

- 当 V(S) 时导致唤醒了等待 S 的资源，此时说明之前已经有 S < 0，即 V(S) 后仍有 S ≤ 0
- 当执行 P(S) **后**，只有当 S < 0，该进程才会进入资源等待队列，一定要注意题目中是 P/V(S) 之前还是之后

进程通信

- 共享内存：Redis
- 消息传递：WebSocket
- 管道传输：RabbitMQ

管程：一次只允许一个进程进入冠城

生产-消费者问题：通过一个 mutex = 1 控制缓冲区的访问权，通过 full = 0，empty = n 来控制缓冲区中资源的数量和空闲的位置

```c
Semaphore mutex = 1, full = 0, empty = n;
void produce(){
    P(empty);
    P(mutex);
    work();
    V(mutex);
    V(full);
}

void consume(){
    P(full);
    P(mutex);
    work();
    V(mutex);
    V(empty);
}
```

在有多个生产、消费者时，或有生产消费链时，要使用多个 mutex 去控制每一个缓冲区的访问权，多个 full 和 empty 去控制缓冲区的资源存储情况

读写互斥问题：通过 count = 0 来记录当前读者数量，通过 rw 来控制读写权限，通过 mutex 来控制操作 count 的权限

- 必须用 mutex 给 count 的操作（+1/-1）上锁，不然多个读者同时访问时将出现脏读

基本的读者进程

```c
read(){
    // 要读了，要修改 count++ 了，事先要拿 count 的访问权
    P(mutex);
    if(count == 0){ // 当为第一个读者，要等待读写权限
        P(rw)
    }
    count++;
    V(mutex)
    reading();
    // 读完了，要修改 count-- 了，事先拿 count 访问权
    P(mutex);
    count--;
    if(count == 0){
        V(rw) // 当没有读者，释放读写权限
    }
    V(mutex)
}
```

基本写者进程，就是这么简单

```c
write(){
    P(rw);
    writting();
    V(rw);
}
```

这有很多变式，如单向路口，同时仅限一方通行：此时需要设置两个 count 去记录两批读者的数量，两个 mutex 来给两个 count 上锁，用一个 pass 信号量给“通行”这一操作上锁（即一方通行时，另一方被 pass 锁上）

哲学家进食问题（一个圆桌）：通过一组信号量控制哲学家拿筷子的操作，为了避免哲学家同时拿左手筷子导致死锁，采用给哲学家拿左右两只筷子（两个连续操作）上锁的方式

```c
Semagore stick[1,1,1,1,1];
Semagore mutex = 1; // 给拿两只筷子操作上锁
void eat(int i){ // 第 i 个哲学家进食
    P(mutex);
    P(stick[i] && stick[(i+1)%5]);
    eatting;
    V(stick[i] && stick[(i+1)%5]);
    V(mutex);
}
```

这样每次保证只有一个哲学家进食，不可能出现有其他哲学家抢他筷子的情况发生（会导致忙等，但不失为一种同步互斥方案）

注意：在写题时，一定要写 main 函数，若有需要，应将主要功能用 while(1) 包含起来持续运行

### 死锁

当有 n 个进程时，就绪队列最多有 n-1 个进程，而阻塞队列最多有 n 个进程

- 当发生死锁时，n 个进程全被阻塞

死锁预防：破坏死锁产生的必要条件

- 破坏互斥条件：SPOOLing
- 破坏不可剥夺条件：抢夺式分配
- 破坏保持请求条件：一次性分配
- 破坏循环等待条件：给资源编号

死锁避免：银行家算法

- 系统处于不安全状态**可能**发生死锁：因为可以主动撤销资源，不是说不安全就一定要继续进行下去直到发展成死锁

死锁检测：资源分配图，矩形中的圆圈表示资源，圆圈表示进程，箭头朝进程表示分配，朝资源表示请求分配，通过撤销进程来判断资源是否足够分配（若撤销了还不够，说明产生死锁）

死锁解除

- 撤销所有陷入死锁的进程：一刀切
- 逐个撤销陷入死锁中的进程：逐个抓
- 使陷入死锁中的进程逐个放弃所占有资源，直到死锁消失：注意此时并不撤销进程，只是令其放弃资源，转入阻塞队列

## 存储管理

### 存储管理概述

通过维护两个寄存器对物理地址进行查找和保护

- 基地址寄存器，又叫重定位寄存器
- 界地址寄存器

一个系统只维护一个重定位寄存器（因为同时只运行一个进程，多了没用）

| 产生内部碎片   | 产生外部碎片   |
| -------------- | -------------- |
| 固定分区分配   | 动态分区分配   |
| 分页式存储     | 分段式存储     |
| 请求分页式存储 | 请求分段式存储 |

存在外部碎片的分配方式通过紧凑技术（拼接技术）来合并较小的连续的碎片，希望能得以利用

存储空间的最大值

- 实际最大值：内存加外存的总空间
- 理论最大值：与地址寄存器的位数有关，如 32 位，则最大值为 2^32 B

注意，逻辑地址的寻址（即对内存的访问）是以字节为单位（基地址+偏移地址），而内存的分配是以内存块为单位，二者要分清

### 连续存储

就是内存管理

程序的链接、装入

- 程序在链接时形成逻辑地址
- 在装入时对逻辑地址进行转换，为物理地址（由硬件完成）

静态装入：在编程阶段就把物理地址规定好

地址重定位

- 静态地址重定位：一次性装入时定位
- 动态地址重定位：边执行边定位

固定分区分配：对内存进行固定分区，如将一整块内存均分为 100 份，每个分区只装入一道作业

- 显然，这样会产生内部碎片（即分区内部无法利用的区域），而不会产生外部碎片（整块内存都被分区，无残留）

动态分区分配：根据作业所需内存为其分配内存，同样是每个分区装一道作业，这样会产生外部碎片（有残留的未形成分区的内存）

**动态**分区分配算法

- 首次适应 FF：地址升序
- 邻近适应 NF：地址升序，循环队列，继承指针位置遍历
- 最差适应 WF：空闲区大小降序排列
- 最优适应 BF：空闲区大小升序排列（产生最多的内部碎片）

### 离散存储

分页

- 每个进程都有其对应的一张页表
- 页表的始地址存储在寄存器中

页面大小的制定：进程平均大小、页表长度（无论如何制定，每个页面的大小都是一样的）

分段

- 程序如何分段在编程时决定
- 每个进程都有其对应的一张段表

段页式

- 采用分段的方式存储逻辑地址，采用分页来存储物理地址
- 每个程序对应一个段表，每个分段对应一张页表

这里涉及到一些关于**页表项、多级页表、页表大小**的计算题：如一个页表项占 2B，一页 8KB，虚拟地址 48 位，实地址 36 位

可以获得的信息有

1. 一页可存 4KB/8B = 2^9 个页表项
2. 页内偏移地址为 8KB = 2^12，需要 12 位
3. 虚拟地址 48 位，去掉页内偏移的 12 位，共可给 2^36 个页编号
4. 要存储这 2^36 个页，需要 2^36 个页表项，由于一个进程一张页表（这张页表必须能够囊括所有的页），又因为一张表可存 2^9 个项，有 (2^9)^4 = 2^36，故需要 4 级页表来进行存储

一定要注意题目中的隐藏信息，如

- 通过页面大小得知偏移地址位数
- 通过虚拟地址位数、偏移地址位数得知最大页面容量
- 通过页面大小、页表项大小得知一个页面可存储的页表项数

在考虑页面调用时，一定使用的是虚拟地址位数，而不是实地址（已经扩充过了，肯定要用啊，不然扩了不管等于没扩）

### 虚拟存储

用于扩充内存容量

- 请求分页式
- 请求分段式

遵循程序的局部性原理（对程序的不均匀访问）

页面置换算法

- 先进先出：FIFO
- 最近最久未使用：LRU
- 最近未使用：NRU

内存分配策略

- 静态分配局部置换：对于每道作业，页框大小不变，自己调度自己的
- 动态分配全局置换：页框大小任意，缺页时即从物理块队列中取出并分配（容易盲目给进程分配内存块，从而降低多道程序并发能力）
- 动态分配局部置换：页框可变，但相对固定，当缺页时从自己的页框中进行调度，当**频繁缺页**时系统给其分配更多物理块

一定是不存在静态分配全局置换的，都静态分配固定了页框，还全局分配个集贸

注意页面的置换 ≠ 调页

- 页置换：指页面一进一出，将页面 1 调入空闲的页框，这不叫页置换
- 调页：指将页面从磁盘调入内存，这包含页置换

抖动与 Belady 现象

- 所有的页面置换算法都无法避免抖动：即频繁页面调度的现象
- 只有 FIFO 存在 Belady 现象：即增大所分配页框大小，其页面调度次数不降反升的现象

## 文件管理

用户的输入输出以文件为基本单位

### 文件存储管理

文件的逻辑结构、物理结构

存储逻辑结构：逻辑结构是为了方便用户而设计

- 流式文件：以字节 B 为单位
- 记录式文件
  - 连续文件
  - 链接文件
  - 索引文件
  - 散列文件

存储物理结构：文件实际存储在磁盘中的结构

- 连续分配：支持随机访问，不易于扩展，存在外部碎片
- 链式分配：分为隐式和显式（链接表 FAT，不支持重名），无外部碎片
- 索引分配：既支持随机访问，也易于扩展

文件控制块：FCB，类似于 PCB，一个文件对应一个

索引节点：FCB 的简化版本，为了减少内存占用（当文件打开后，其 FCB 将被复制到内存中的文件打开表），同样每个文件对应一个索引结点

在索引结构下，每个文件都有一张索引表，记录其每个索引记录的逻辑地址，注意是逻辑地址，物理地址的转换涉及存储管理和硬件（上一章的内容）

- 且索引结构下索引结点的地址项记录的是该文件索引表的始地址

文件的硬链接、软链接

- 软链接的计数器单独存在，初始化为 1，原文件删除后不影响软链接计数器
- 硬链接的计数器初始化为 n+1，n 为建立连接前原文件计数器 count 的取值，当硬链接的文件被删除一份时，count 减一

文件的数量上限，和页面数量上限类似，与地址编码有关，如若记录索引结点的地址位数为 4B，即 32 位，则文件最多有 2^32 个

### 目录管理

文件目录：用于存放各文件的 FCB 或索引结点信息，同时也是一个文件，叫做目录文件

二级目录：允许重名，但不能对文件分类，缺乏灵活性

树形目录：会增加访问磁盘的次数

### 文件系统

**用户权限**和**文件权限**共同实现对文件的保护功能

**从用户角度看**，操作系统引入文件系统的目的是：实现对文件按名存取

外存空间管理：空闲磁盘管理

- 空闲表法
- 空闲链表法
- 位示图：位示图法只能用在空闲磁盘空间的管理
- 成组链接法：UNIX

注意 FAT（文件分配表）也可以用于管理空闲和非空闲的磁盘空间，但不允许同名文件

- 记得吗，在文件的逻辑结构中，显式链接文件（静态链表）结构，next  指向下一个空闲块，若 next < 0 则说明块被占用

动态分区存储管理（上一章的），最佳适应算法那里，记得不，为什么我会写在这？

虚拟文件系统：VFS

- 超级块对象
- 索引结点对象
- 目录项对象
- 文件对象

## 外设管理

### I/O 管理

> I/O 设备实际上属于一种特殊的文件管理，OS 将其作为文件进行管理

缓冲技术：为了解决 CPU 和设备速度不匹配问题

- 单缓冲区
- 双缓冲区
- 缓冲池

计算任务最快时间，类似流水线的计算方法，着眼于当前状态到下一同一状态所经时间

### 设备独立性软件

设备无关性：用户在编程时使用的设备和实际的物理设备无关（设备无关性和设备独立性是一个东西）

SPOOLing 技术

- 输入输出井
- 输入输出缓冲区
- 输入输出进程

SPOOLing 的特点

- 加快作业执行速度
- 使独占设备虚拟为共享设备
- 无需独占设备

但注意，虽然是使成为共享设备，但实际上实现的是物理设备的**虚拟分配**

文件系统和设备驱动程序之间的接口：设备开关表

### 磁盘管理

磁盘调度算法

- 先来先服务：FCFS
- 最短寻道时间优先：SSTF
- 电梯调度算法：SCAN
- 优化的电梯调度算法：C-SCAN

读写磁盘最重要的耗时：寻道时间

## 分布式和网络操作系统

什么是分布式 OS：指把多个处理机通过线路互联而构成的统一的系统，该系统的处理和控制分布在各个处理机上

主要特点：分布性、自治性、模块性、并行性

主要功能：数据迁移、分布式进程同步、任务分配、资源管理

分布式 OS 和网络 OS 的主要区别

- 通信和资源方面：分布式 OS 透明性强，系统中节点无主从之分，都可以共享系统中全部资源，多个节点间共同协作完成同一任务；而网络 OS 共享同一个服务器资源
- 故障处理方面：当分布式 OS 单节点机出现故障时，系统仍可使用
