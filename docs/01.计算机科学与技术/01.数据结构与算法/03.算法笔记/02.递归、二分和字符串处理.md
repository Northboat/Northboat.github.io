---
date: 2022-9-17
permalink: /pages/190291/
title: é€’å½’ã€äºŒåˆ†å’Œå­—ç¬¦ä¸²å¤„ç†
author: 
  name: Northboat
  link: https://github.com/Northboat
---

## é“¾è¡¨çš„é€’å½’

```java
// Definition for singly-linked list.
public class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
```

### ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹

[24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹](https://leetcode.cn/problems/swap-nodes-in-pairs/)

```java
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head || !head->next){
            return head;
        }
        ListNode* next = head->next;
        head->next = swapPairs(next->next);
        next->next = head;
        return next;
    }
};
```

æˆ‘è¿˜æ˜¯æ›´ä¹ æƒ¯è¿­ä»£çš„å†™æ³•ï¼Œè¿™æ›´ç¬¦åˆå›ºå®šæ€ç»´

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode h = head.next;
        ListNode pre = null, cur = head;
        while(cur != null){
            swap(pre, cur);
            pre = cur;
            cur = cur.next;
        }
        return h;
    }


    public void swap(ListNode pre, ListNode cur){
        if(cur.next == null){
            return;
        }
        ListNode next = cur.next;
        if(pre != null){
            pre.next = next;
        }
        cur.next = next.next;
        next.next = cur;
    }
}
```

### åè½¬é“¾è¡¨

[206. åè½¬é“¾è¡¨](https://leetcode.cn/problems/reverse-linked-list/)

```c
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head || !head->next){
            return head;
        }
        ListNode* rtn = reverseList(head->next);
        head->next->next = head;
        head->next = NULL;
        return rtn;
    }
};
```

### é‡æ’é“¾è¡¨

[143. é‡æ’é“¾è¡¨](https://leetcode.cn/problems/reorder-list/)ï¼šå°†é“¾è¡¨`1 â†’ 2 â†’ 3 â†’ ... â†’ n-1 â†’ n`åŸåœ°ä¿®æ”¹ä¸º`1 â†’ n â†’ 2 â†’ n-1 â†’ ... â†’ n/2`

1. æ‰¾åˆ°ä¸­ç‚¹å¹¶åˆ†å‰²ä¸ºä¸¤ä¸ªé“¾è¡¨ï¼ˆè¿™ä¸ªåˆ†å‰²ç‚¹æœ‰ç‚¹è®²ç©¶ï¼Œéœ€è¦æ³¨æ„ä¸€ä¸‹ï¼‰
2. ç¿»è½¬ç¬¬äºŒä¸ªé“¾è¡¨ï¼ˆé€’å½’ç¿»è½¬ï¼‰
3. åŸåœ°äº¤å‰åˆå¹¶ä¸¤ä¸ªé“¾è¡¨ ï¼ˆå·§ç”¨ä¸´æ—¶å˜é‡è¿­ä»£ï¼‰

```java
class Solution {
    public void reorderList(ListNode head) {
        ListNode mid = midNode(head);  
        ListNode l2 = reverse(mid.next);  
        mid.next = null;    
        ListNode l1 = head;       
        merge(l1, l2);
    }

    public ListNode midNode(ListNode head){
        ListNode slow = head, fast = head;
        while(fast.next!=null && fast.next.next!=null){
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }

    public ListNode reverse(ListNode head){
        if(head==null || head.next==null){
            return head;
        }
        ListNode newHead = reverse(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }

    public ListNode merge(ListNode l1, ListNode l2){
        ListNode head = l1;
        ListNode cur = head;
        ListNode c1 = l1.next;
        ListNode c2 = l2;
        while(c1!=null || c2!=null){
            cur.next = c2;
            c2 = c2.next;
            cur = cur.next;
            if(c1==null && c2==null){
                break;
            }
            cur.next = c1;
            c1 = c1.next;
            cur = cur.next;          
        }
        return head;
    }
}
```

### K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨

[25. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

- vector è®°å½•ç»„èµ·å§‹èŠ‚ç‚¹
- å°†æ¯ç»„æœ«å°¾ç½®ç©º
- æ¯ç»„ç¿»è½¬
- é“¾è¡¨ç›¸æ¥

```c
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        vector<ListNode*> vec;
        int index = 0;
        while(head){
            if(index++ % k == 0){
                vec.push_back(head);
            }
            head = head->next;
        }
        for(int i = 0; i < vec.size(); i++){
            ListNode* tail = vec[i];
            int flag = 0;
            // å°†æœ«å°¾æŒ‡å‘ç©º 
            for(int j = 0; j < k-1; j++){
                if(!tail->next){
                    flag = 1;
                    break;
                }
                tail = tail->next;
            }
            tail->next = NULL;
            if(flag){
                continue;
            }
            //print(vec[i]);
            vec[i] = reverseList(vec[i]);
        }
        joinList(vec);
        return vec[0];
    }

    ListNode* reverseList(ListNode* head){
        if(!head || !head->next){
            return head;
        }
        ListNode* rtn = reverseList(head->next);
        head->next->next = head;
        head->next = NULL;
        return rtn;
    }

    void joinList(vector<ListNode*> v){
        for(int i = 0; i < v.size()-1; i++){
            getTail(v[i])->next = v[i+1];
        }
    }

    ListNode* getTail(ListNode* head){
        while(head->next){
            head = head->next;
        }
        return head;
    }
};
```

## æ ‘ä¸å›¾çš„é€’å½’

```c
// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
```

### å¯¹ç§°äºŒå‰æ ‘

[101. å¯¹ç§°äºŒå‰æ ‘](https://leetcode.cn/problems/symmetric-tree/)ï¼šåˆ¤æ–­äºŒå‰æ ‘æ˜¯å¦å®Œå…¨å¯¹ç§°

```c
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root == NULL){
            return true;
        }
        return dfs(root->left, root->right);
    }

    bool dfs(TreeNode* left, TreeNode* right){
        if(left == NULL && right == NULL){
            return true;
        }
        if(left == NULL || right == NULL){
            return false;
        }
        if(left->val != right->val){
            return false;
        }
        return dfs(left->right, right->left) && dfs(left->left, right->right);
    }
};
```

### è·¯å¾„æ€»å’Œ

[112. è·¯ç»æ€»å’Œ](https://leetcode.cn/problems/path-sum/)ï¼šåˆ¤æ–­æ•°ä¸­æ˜¯å¦å­˜åœ¨å’Œä¸º target çš„è·¯å¾„ï¼Œè·¯å¾„æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹ï¼ˆé€’å½’ dfsï¼‰

```c
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root == NULL){
            return false;
        }
        if(root->val == targetSum && root->left == NULL && root->right == NULL){
            return true;
        }
        return hasPathSum(root->left, targetSum-root->val) || hasPathSum(root->right, targetSum-root->val);
    }
};
```

### ç¿»è½¬äºŒå‰æ ‘

[226. ç¿»è½¬äºŒå‰æ ‘](https://leetcode.cn/problems/invert-binary-tree/)ï¼šå°†äºŒå‰æ ‘å·¦å³ç¿»è½¬ï¼ˆååºéå†ï¼‰

```c
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        dfsInvert(root);
        return root;
    }

    void dfsInvert(TreeNode* node){
        if(node == NULL){
            return;
        }
        dfsInvert(node->left);
        dfsInvert(node->right);
        TreeNode* temp = node->left;
        node->left = node->right;
        node->right = temp;
    }
};
```

### éªŒè¯äºŒå‰æœç´¢æ ‘

[98. éªŒè¯äºŒå‰æœç´¢æ ‘](https://leetcode.cn/problems/validate-binary-search-tree/)ï¼šè¢«æŠ˜ç£¨äº†ï¼Œå…¶å®æŠ“ä½äº†æ˜¯è¾¹ç•Œé—®é¢˜ï¼Œä½†æ²¡æ‰¾å‡†ï¼Œå¦å¤–è¿™ä¸ª int çš„æº¢å‡ºçœŸå‡ æŠŠæ¶å¿ƒï¼Œä¹Ÿä¸è¯´ä¸€å£°

```c
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        return dfs(root, LONG_MIN, LONG_MAX);
    }

    bool dfs(TreeNode* node, long min, long max){
        if(node == NULL){
            return true;
        }
        long val = node->val;
        if(val <= min || val >= max){
            return false;
        }
        return dfs(node->left, min, val) && dfs(node->right, val, max);
    }
};
```

### äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

[235. äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)ï¼šå…¶å®å¾ˆç®€å•ï¼Œå› ä¸ºå¹³è¡¡ï¼Œæ‰€ä»¥å½“ç›®æ ‡å€¼å’Œå½“å‰èŠ‚ç‚¹ä¹‹å·®å¼‚å·æ—¶ï¼Œè¯´æ˜åœ¨å½“å‰èŠ‚ç‚¹ä¸¤ä¾§

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        int cur = root.val;
        if((cur < p.val && cur > q.val) || (cur > p.val && cur < q.val) ||
           (cur == p.val) || (cur == q.val)){
            return root;
        }
        if(cur > p.val && cur > q.val){
            return lowestCommonAncestor(root.left, p, q);
        } else {
            return lowestCommonAncestor(root.right, p, q);
        }
    }
}
```

### äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

[236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)ï¼šä¸åŒäºäºŒå‰æœç´¢æ ‘ï¼Œè¿™é‡Œéœ€è¦å¯¹èŠ‚ç‚¹çš„å·¦å³å­èŠ‚ç‚¹å‡éå†ï¼Œä¸èƒ½é€šè¿‡å€¼å¤§å°è¿›è¡Œé€‰æ‹©ï¼Œä¹Ÿä¸èƒ½é€šè¿‡å·®å€¼ä¹˜ç§¯æ˜¯å¦åŒå·åˆ¤æ–­æ˜¯å¦èŠ‚ç‚¹ä½äºæ ¹çš„åŒä¸€è¾¹

1. dfs å‡½æ•°è¿”å›å€¼åˆ¤æ–­å½“å‰ç»“ç‚¹æ˜¯å¦æ˜¯æŸä¸€ç›®æ ‡èŠ‚ç‚¹çš„ç¥–å…ˆï¼ˆæ ¸å¿ƒæ€è·¯ï¼‰
2. å½“èŠ‚ç‚¹åŒæ—¶ä¸ºä¸¤ä¸ªç›®æ ‡èŠ‚ç‚¹çš„ç¥–å…ˆæ—¶ï¼Œæˆ‘è®¤ä¸ºä»–æ˜¯äºŒè€…å…¬å…±ç¥–å…ˆï¼Œèµ‹å€¼ç»™é™æ€å˜é‡ res
3. ä½ å¯èƒ½ä¼šç–‘æƒ‘è¿™æ ·æ‰¾å‡ºæ¥çš„å…¬å…±ç¥–å…ˆæ·±åº¦æ˜¯å¦æ˜¯æœ€å¤§çš„ï¼Ÿ
   - ç”±äºæ·±åº¦ä¼˜å…ˆéå†çš„é¡ºåºé—®é¢˜ï¼Œæˆ‘æœ€åä¸€æ¬¡æ‰¾åˆ°çš„å…¬å…±ç¥–å…ˆä¸€å®šæ˜¯â€œæœ€æ·±â€çš„ï¼Œå³æœ€è¿‘çš„å…¬å…±ç¥–å…ˆ
   - å¦å¤–ï¼Œå…¶å®é™¤äº†â€œæœ€è¿‘çš„å…¬å…±ç¥–å…ˆâ€ï¼Œå…¶ä»–çš„å…¬å…±ç¥–å…ˆå…¶å®å¹¶ä¸ä¼šé€šè¿‡`if`åˆ¤æ–­çš„ ğŸ¤“

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        dfs(root, p, q);
        return res;
    }

    TreeNode res;
    public boolean dfs(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null){
            return false;
        }
        boolean left = dfs(root.left, p, q);
        boolean right = dfs(root.right, p, q);
        // åªæœ‰å½“åŒæ—¶ä¸ºä¸¤ä¸ªç›®æ ‡èŠ‚ç‚¹çš„ç¥–å…ˆæ—¶ï¼Œæˆ‘å†è¿›è¡Œæ ‡è®°
        if((left && right) || ((left || right) && (root.val == p.val || root.val == q.val))){
            res = root;
        }
        // æˆ‘åªéœ€è¦åˆ¤æ–­å½“å‰èŠ‚ç‚¹æ˜¯å¦æ˜¯æŸä¸€ç›®æ ‡èŠ‚ç‚¹çš„ç¥–å…ˆ
        return left || right || root.val == p.val || root.val == q.val;
    }
}
```

### å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘

[108. å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

- å› ä¸ºæ•°ç»„æœ‰åºï¼Œä¸”è¦æ„é€ äºŒå‰æœç´¢æ ‘ï¼Œæ•°ç»„ä¸­é—´å…ƒç´ ä¸€å®šæ˜¯æ ¹èŠ‚ç‚¹
- æ®æ­¤é€’å½’

```java
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return build(nums, 0, nums.size());
    }

    TreeNode* build(vector<int>& nums, int left, int right){
        if(left >= right){
            return NULL;
        }
        int mid = (left+right) / 2;
        TreeNode* node = new TreeNode(nums[mid]);
        node->left = build(nums, left, mid);
        node->right = build(nums, mid+1, right);
        return node;
    }
};
```

### ä»å‰åºå’Œä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

[106. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

é¦–å…ˆè¦æ˜ç¡®å‰åºã€ä¸­åºéå†åºåˆ—çš„ç»“æ„
- å‰åºï¼šæ ¹èŠ‚ç‚¹ [å·¦å­æ ‘] [å³å­æ ‘]
- ä¸­åºï¼š[å·¦å­æ ‘] æ ¹èŠ‚ç‚¹ [å³å­æ ‘]

åœ¨ä¸­åºéå†ä¸­æ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œæ ¹èŠ‚ç‚¹å·¦ä¾§æ˜¯ä»–çš„å·¦å­æ ‘ï¼Œå³ä¾§æ˜¯ä»–çš„å³å­æ ‘ï¼Œå¯ä»¥è½»æ˜“è·å¾—å·¦å­æ ‘çš„é•¿åº¦ length

å®šä½å‰åºéå†çš„åºåˆ—çš„æ ¹èŠ‚ç‚¹ï¼Œæˆ‘ä»¬å·²çŸ¥`preorder[0]`æ˜¯æ•´ä¸ªæ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œæ­¤æ—¶ä»¤ index = 0ï¼Œå¾ˆå®¹æ˜“å¾—çŸ¥**æ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹**å°±æ˜¯`preorder[index+1]`ï¼Œåœ¨æ ¹æ®æ ¹èŠ‚ç‚¹åœ¨ inorder ä¸­ä½ç½® posï¼Œ**æ ¹èŠ‚ç‚¹çš„å³å­æ ‘çš„æ ¹èŠ‚ç‚¹**å°±æ˜¯`preorder[index+pos+1] = preorder[index+length]`

æ®æ­¤é€’å½’è·å–æ•´é¢—äºŒå‰æ ‘

```java
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        return build(preorder, 0, inorder, 0, preorder.size());
    }

    TreeNode* build(vector<int>& preorder, int index, vector<int> inorder, int left, int right){
        if(left >= right){
            return NULL;
        }
        TreeNode* root = new TreeNode(preorder[index]);
        int pos = find(inorder.begin(), inorder.end(), root->val) - inorder.begin();
        int length = pos-left;
        root->left = build(preorder, index+1, inorder, left, pos);
        root->right = build(preorder, index+length+1, inorder, pos+1, right);
        return root;
    }
};
```

### åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹

[450. åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹](https://leetcode.cn/problems/delete-node-in-a-bst/)ï¼šå¥½éš¾ï¼ŒåŸºæœ¬æŠ„çš„ï¼ŒåŸºæœ¬æ€è·¯æ˜¯

- æ‰¾åˆ°å°†è¦åˆ é™¤çš„èŠ‚ç‚¹ node
- å°†`node->right`çš„æœ€å·¦å¶å­ leaf ä½œä¸ºæ–°çš„ node æ¥åœ¨æ ‘ä¸Šï¼Œå³ç”¨ leaf æ›¿æ¢ node
  - è¿™æ„å‘³ç€ï¼š`leaf->left = node->left; leaf->right = node->right`
  - ä¸”`node->right`ä¸­ä¸å« leafï¼Œå³è¦åœ¨`node->right`ä¸­åˆ é™¤ leaf

```c
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(!root){
            return NULL;
        }
        if(root->val == key){
            if(!root->left && !root->right){ //å¦‚æœä¸ºå¶å­èŠ‚ç‚¹
                return NULL;
            }
            if(!root->left){     // å¦‚æœæ²¡æœ‰å·¦å­æ ‘
                return root->right;
            }
            if(!root->right){    // å¦‚æœæ²¡æœ‰å³å­æ ‘
                return root->left;
            }
            TreeNode* new_root = root->right;
            while(new_root->left){
                new_root = new_root->left;
            }
            int val = new_root->val;
            root->right = deleteNode(root->right, val);
            new_root->left = root->left;
            new_root->right = root->right;
            return new_root;
        }

        if(root->val < key){
            root->right = deleteNode(root->right, key);
        }
        if(root->val > key){
            root->left = deleteNode(root->left, key);
        }
        return root;
    }
};
```

### äºŒå‰æ ‘çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–

[296. äºŒå‰æ ‘çš„åºåˆ—åŒ–ä¸ååºåˆ—åŒ–](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)

- éšä¾¿éå†ä¸€æ¬¡ï¼Œè¦æ ‡è®° null
- å†æŒ‰ç…§éå†é¡ºåºè¿›è¡Œæ„é€ ï¼Œéº»çƒ¦

```c
class Codec {
public:

    list<string> strs;

    void dfs(TreeNode* root, string& s){
        if(!root){
            s += "none,";
            return;
        }
        s += to_string(root->val)+",";
        dfs(root->left, s);
        dfs(root->right, s);
    }

    TreeNode* build(){
        if(strs.front() == "none"){
            strs.erase(strs.begin());
            return NULL;
        }
        TreeNode* root = new TreeNode(stoi(strs.front()));
        strs.erase(strs.begin());
        root->left = build();
        root->right = build();
        return root;
    }

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string s;
        dfs(root, s);
        cout << s;
        return s;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        string str;
        for(auto& ch: data){
            if(ch == ','){
                strs.push_back(str);
                str.clear();
            } else {
                str.push_back(ch);
            }
        }
        if(!str.empty()){
            strs.push_back(str);
            str.clear();
        }
        return build();
    }
};

// Your Codec object will be instantiated and called as such:
// Codec ser, deser;
// TreeNode* ans = deser.deserialize(ser.serialize(root));
```

å›¾é€’å½’

### é’¥åŒ™å’Œæˆ¿é—´

[841. é’¥åŒ™å’Œæˆ¿é—´](https://leetcode.cn/problems/keys-and-rooms/)

- éå†æˆ¿é—´ä¸­çš„é’¥åŒ™ï¼Œç”¨ flags[i] è¡¨ç¤ºç¬¬ i ä¸ªæˆ¿é—´æ˜¯å¦è¢«è®¿é—®è¿‡
- å†æ¬¡è®¿é—®åˆ°ç›´æ¥è·³è¿‡ï¼Œæœªè®¿é—®åˆ°åˆ™è®¿é—®å¹¶éå†è¯¥æˆ¿é—´ä¸­çš„é’¥åŒ™
- å¦‚æœ flags ä¸­å­˜åœ¨ falseï¼Œåˆ™è¯´æ˜æœªéå†å®Œ
- å› ä¸ºæ•´ä¸ªå›¾åªæœ‰ä¸€ä¸ªå…¥å£ï¼Œå³ rooms[0]ï¼Œå¦‚æœä»ç£å…¥å£æ·±åº¦éå†ä¸å®Œï¼Œåˆ™è¯´æ˜è¯¥å›¾æ— æ³•é€šè¿‡ rooms[0] åˆ°è¾¾æ‰€æœ‰èŠ‚ç‚¹

```c
Solution {
public:

    bool canVisitAllRooms(vector<vector<int>>& rooms) {
        vector<int> flags(rooms.size(), 0);
        dfs(rooms, flags, 0);
        for(auto& flag: flags){
            if(!flag){
                return false;
            }
        }
        return true;
    }

    void dfs(vector<vector<int>>& rooms, vector<int>& flags, int index){
        if(flags[index]){
            return;
        }
        vector<int> keys = rooms[index];
        flags[index] = 1;
        for(auto& key: keys){
            dfs(rooms, flags, key);
        }     
    }
};
```

## åŒæŒ‡é’ˆ

### é“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹

[876. é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹](https://leetcode.cn/problems/middle-of-the-linked-list/)

```c
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast && fast->next){
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
};
```

### é‡æ’é“¾è¡¨

[143. é‡æ’é“¾è¡¨](https://leetcode.cn/problems/reorder-list/)ï¼šæ—¶éš”ä¸‰å¹´çš„ Java å®ç°ï¼Œè¿˜æ˜¯ä¸€ä¸ªæ€è·¯ï¼ŒäººçœŸçš„ä¸ä¼šå˜

```java
class Solution {
    public void reorderList(ListNode head) {
        ListNode fast = head, slow = head, pre = null;
        while(fast != null){
            pre = slow;
            slow = slow.next;
            fast = fast.next;
            if(fast != null){
                fast = fast.next;
            }
        }
        pre.next = null;

        ListNode p = reverse(slow);
        ListNode q = head;
        merge(q, p);
    }


    public ListNode reverse(ListNode cur){
        if(cur == null || cur.next == null){
            return cur;
        }
        ListNode next = cur.next;
        ListNode head = reverse(next);
        next.next = cur;
        cur.next = null;
        return head;
    }

    public ListNode merge(ListNode q, ListNode p){
        ListNode head = q;
        int count = 0;
        while(q != null && p != null){
            if(count % 2 == 0){
                ListNode t = q.next;
                q.next = p;
                q = t;
            } else {
                ListNode t = p.next;
                p.next = q;
                p = t;
            }
            count++;
        }
        return head;
    }
}
```

### ä¸‰æ•°ä¹‹å’Œ

[15. ä¸‰æ•°ä¹‹å’Œ](https://leetcode.cn/problems/3sum/)ï¼šæ’åºåŠ åŒæŒ‡é’ˆ

- è§£å†³é‡å¤é—®é¢˜ï¼Œå›ºå®šèµ·å§‹ä½ï¼Œåˆ©ç”¨åŒæŒ‡é’ˆç¼©å°èŒƒå›´
- å½“ç¢°åˆ°è¿ç»­çš„ç›¸åŒå…ƒç´ ç›´æ¥è·³è¿‡ï¼Œé¿å…é‡å¤

```c
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        vector<vector<int>> res;
        for(int i = 0; i < n-2; i++){
            if(nums[i] > 0){
                break;
            }
            if(i>0 && nums[i]==nums[i-1]){
                continue;
            }
            int l = i+1;
            int r = n-1;
            while(l < r){
                int sum = nums[i]+nums[l]+nums[r];
                if(sum < 0){
                    while(l<r && nums[l]==nums[++l]);
                } else if(sum > 0){
                    while(l<r && nums[r]==nums[--r]);
                } else{
                    vector<int> row = {nums[i], nums[l], nums[r]};
                    res.push_back(row);
                    while(l<r && nums[l]==nums[++l]);
                    while(l<r && nums[r]==nums[--r]);
                }
            }
        }
        return res;
    }
};
```

### ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

[105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)ï¼šé€šè¿‡åŒæŒ‡é’ˆè§„èŒƒå­æ ‘èŒƒå›´

```c
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        return build(preorder, 0, inorder, 0, preorder.size());
    }

    TreeNode* build(vector<int>& preorder, int index, vector<int> inorder, int left, int right){
        if(left >= right){
            return NULL;
        }
        TreeNode* root = new TreeNode(preorder[index]);
        int pos = find(inorder.begin(), inorder.end(), root->val) - inorder.begin();
        int length = pos-left;
        root->left = build(preorder, index+1, inorder, left, pos);
        root->right = build(preorder, index+length+1, inorder, pos+1, right);
        return root;
    }
};
```

## äºŒåˆ†æ³•

### äºŒåˆ†æŸ¥æ‰¾

[704. äºŒåˆ†æŸ¥æ‰¾](https://leetcode.cn/problems/binary-search/)

```c
class Solution {
public:
    int search(vector<int>& nums, int target) {
        return binarySearch(nums, target, 0, nums.size()-1);
    }

    int binarySearch(vector<int>& nums, int target, int left, int right){
        if(left > right){
            return -1;
        }
        int mid = (left+right) / 2;
        if(nums[mid] == target){
            return mid;
        }
        if(nums[mid] > target){
            return binarySearch(nums, target, left, mid-1);
        } else {
            return binarySearch(nums, target, mid+1, right);
        }
    }
};
```

### æœç´¢æ’å…¥ä½ç½®

[35. æœç´¢æ’å…¥ä½ç½®](https://leetcode.cn/problems/search-insert-position/)ï¼šæ³¨æ„è¿™é‡Œçš„è¿”å›æ¡ä»¶æ˜¯ left > rightï¼Œå› ä¸ºè¦æ‰¾åˆ°æ¯” target å°çš„å€¼çš„ä¸‹ä¸€ä¸ªä½ç½®æ’å…¥

é€’å½’è§£æ³•

~~~c
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        return binarySearch(nums, target, 0, nums.size()-1);
    }

    int binarySearch(vector<int>& nums, int target, int left, int right){
        if(left > right){
            return left;
        }
        int mid = left + (right-left)/2;
        if(nums[mid] == target){
            return mid;
        }
        if(nums[mid] < target){
            return binarySearch(nums, target, mid+1, right);
        } else {
            return binarySearch(nums, target, left, mid-1);
        }
    }
};
~~~

è¿­ä»£è§£æ³•

~~~c
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size()-1;
        while(left <= right){
            int mid = left+(right-left)/2;
            if(nums[mid] == target){
                return mid;
            }
            if(nums[mid] < target){
                left = mid+1;
            }
            if(nums[mid] > target){
                right = mid-1;
            }
        }
        return left;
    }
};
~~~

### æœç´¢æ—‹è½¬æ’åˆ—æ•°ç»„

[33. æœç´¢æ—‹è½¬æ’åºæ•°ç»„](https://leetcode.cn/problems/search-in-rotated-sorted-array/)ï¼šå¯¹äºä¸¤æ®µé€’å¢æ•°ç»„ï¼Œå¯»æ‰¾ç›®æ ‡å…ƒç´ ï¼Œä¸”å‰ä¸€æ®µæœ€å°å€¼å¤§äºç¬¬äºŒæ®µæœ€å¤§å€¼ï¼Œå¦‚`[4,5,7,1,2,3]`

- é€šè¿‡æ¯”è¾ƒ target / nums[mid] å’Œ nums[0] åˆ¤æ–­ target / nums[mid] åœ¨ç¬¬ä¸€æ®µè¿˜æ˜¯ç¬¬äºŒæ®µ
- è‹¥ target å’Œ mid åœ¨åŒä¸€æ®µï¼Œåˆ™æ­£å¸¸äºŒåˆ†æŸ¥æ‰¾
- è‹¥ä¸åœ¨åŒä¸€æ®µï¼Œåˆ™ç¼©å°å·¦/å³è¾¹ç•Œï¼Œä½¿ä¹‹åœ¨åŒä¸€æ®µ

```c
class Solution {
public:

    int left, right;

    bool shrink(int cur, int index, int target){
        if(cur == target){
            return true;
        }
        if(cur < target){ left = index+1; }
        else { right = index-1; }
        return false;
    }

    int search(vector<int>& nums, int target) {
        left = 0, right = nums.size()-1;
        int first = nums[0];
        if(first == target){ return 0; }
        while(left <= right){
            int mid = (left+right) / 2;
            if(target > first){
                if(nums[mid] < first){
                    right = mid-1;
                    continue;
                }
                if(shrink(nums[mid], mid, target)){ return mid; }
            } else {
                if(nums[mid] >= first){
                    left = mid+1;
                    continue;
                }
                if(shrink(nums[mid], mid, target)){ return mid; }
            }
        }
        return -1;
    }
};
```

## å­—ç¬¦ä¸²å¤„ç†

### å­—ç¬¦ä¸²ç›¸åŠ 

[415. å­—ç¬¦ä¸²ç›¸åŠ ](https://leetcode.cn/problems/add-strings/?envType=study-plan&id=shu-ju-jie-gou-ji-chu)ï¼šç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸²å½¢å¼çš„éè´Ÿæ•´æ•°`num1`å’Œ`num2` ï¼Œè®¡ç®—å®ƒä»¬çš„å’Œå¹¶åŒæ ·ä»¥å­—ç¬¦ä¸²å½¢å¼è¿”å›

```java
class Solution {
    public String addStrings(String num1, String num2) {
        StringBuilder sb = new StringBuilder();
        int carry = 0;
        for(int i = 0; i < Math.max(num1.length(), num2.length()); i++){
            int a = i < num1.length() ? num1.charAt(num1.length()-i-1)-'0' : 0;
            int b = i < num2.length() ? num2.charAt(num2.length()-i-1)-'0' : 0;
            int s = a + b + carry;
            sb.append(s % 10);
            carry = s / 10;
        }
        if(carry > 0){
            sb.append(carry);
        }
        return sb.reverse().toString();
    }
}
```

å°æŠ€å·§ä¸€å®šè¦è®°ä½ï¼Œæ•°å­—å­—ç¬¦ char å¿«é€Ÿè½¬ int ç›´æ¥`-'0'`

### å­—ç¬¦ä¸²ç›¸ä¹˜

[43. å­—ç¬¦ä¸²ç›¸ä¹˜](https://leetcode.cn/problems/multiply-strings/?envType=study-plan&id=shu-ju-jie-gou-ji-chu)ï¼šç»™å®šä¸¤ä¸ªä»¥å­—ç¬¦ä¸²å½¢å¼è¡¨ç¤ºçš„éè´Ÿæ•´æ•° `num1` å’Œ `num2`ï¼Œè¿”å› `num1` å’Œ `num2` çš„ä¹˜ç§¯ï¼Œå®ƒä»¬çš„ä¹˜ç§¯ä¹Ÿè¡¨ç¤ºä¸ºå­—ç¬¦ä¸²å½¢å¼ï¼Œå°±æ˜¯æ¨¡æ‹Ÿæ‰‹ç®—è¿‡ç¨‹ï¼ŒåŠ æ³•é€šè¿‡ä¸Šé¢çš„`add`å®ç°

```java
class Solution {
    public String multiply(String num1, String num2) {
        if(num1.equals("0") || num2.equals("0")){
            return "0";
        }
        StringBuilder res = new StringBuilder();
        for(int i = 0; i < num1.length(); i++){
            int a = num1.charAt(num1.length()-i-1) - '0';
            int carry = 0;
            StringBuilder sb = new StringBuilder();
            for(int j = 0; j < num2.length(); j++){
                int b = num2.charAt(num2.length()-j-1) - '0';
                int p = a * b + carry;
                sb.append(p % 10);
                carry = p / 10;
            }
            if(carry > 0){
                sb.append(carry);
            }
            sb = sb.reverse();
            for(int k = 0; k < i; k++){
                sb.append(0);
            }
            res = add(res, sb);
        }
        return res.toString();
    }


    public StringBuilder add(StringBuilder num1, StringBuilder num2){
        StringBuilder sb = new StringBuilder();
        int carry = 0;
        for(int i = 0; i < Math.max(num1.length(), num2.length()); i++){
            int a = i < num1.length() ? num1.charAt(num1.length()-i-1)-'0' : 0;
            int b = i < num2.length() ? num2.charAt(num2.length()-i-1)-'0' : 0;
            int s = a + b + carry;
            sb.append(s % 10);
            carry = s / 10;
        }
        if(carry > 0){
            sb.append(carry);
        }
        return sb.reverse();
    }
}
```

### å•è¯è§„å¾‹

[290. å•è¯è§„å¾‹](https://leetcode.cn/problems/word-pattern/?envType=study-plan&id=shu-ju-jie-gou-ji-chu)ï¼šä½¿ç”¨ hashmap åŒå°„å®ç°ä¸€ä¸€å¯¹åº”ï¼Œè¿™é‡Œå•è¯æ¨¡å¼åŒ¹é…å¿…é¡»æ˜¯ä¸€ä¸ªå­—æ¯å¯¹åº”ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä¸€ä¸ªå­—ç¬¦ä¸²å¯¹åº”ä¸€ä¸ªå­—æ¯ï¼Œå³æ»¡è¶³åŒå°„ï¼Œä¸èƒ½æœ‰`[a, nmsl], [b, nmsl]`

```java
class Solution {
    public boolean wordPattern(String pattern, String s) {
        String[] str = s.split(" ");
        if(pattern.length() != str.length){
            return false;
        }
        Map<Character, String> m1 = new HashMap<>();
        Map<String, Character> m2 = new HashMap<>();
        for(int i = 0; i < str.length; i++){
            Character c = pattern.charAt(i);
            String string = str[i];
            if(!m1.containsKey(c) && !m2.containsKey(string)){
                m1.put(c, string);
                m2.put(string, c);
            } else {
                if(m1.containsKey(c) && !m1.get(c).equals(string)){
                    return false;
                }
                if(m2.containsKey(string) && m2.get(string) != c){
                    return false;
                }
            }
        }
        return true;
    }
}
```

### æ ¹æ®å­—ç¬¦å‡ºç°é¢‘ç‡æ’åº

[451. æ ¹æ®å­—ç¬¦å‡ºç°é¢‘ç‡æ’åº](https://leetcode.cn/problems/sort-characters-by-frequency/)ï¼šHashMap ç»Ÿè®¡å‡ºç°é¢‘æ¬¡ â†’ PriorityQueue æ’åºå­—ç¬¦ â†’ StringBuilder æŒ‰åºæ„é€ 

```java
class Solution {
    public String frequencySort(String s) {
        Map<Character, Integer> map = new HashMap<>();
        for(Character c: s.toCharArray()){
            map.put(c, map.getOrDefault(c, 0) + 1);
        }
        // å¤§é¡¶å †
        Queue<Character> queue = new PriorityQueue<>((a, b) -> {
            return map.get(b) - map.get(a);
        });
        for(Character c: map.keySet()){
            queue.offer(c);
        }
        StringBuilder res = new StringBuilder();
        while(!queue.isEmpty()){
            Character c = queue.poll();
            for(int i = 0; i < map.get(c); i++){
                res.append(c);
            }
        }
        return res.toString();
    }
}
```

