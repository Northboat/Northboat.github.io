---
title: åŸºäº MCP çš„å®¡è®¡ Agent å®ç°
date: 2025-6-24
permalink: /pages/aecc6a/
author: 
  name: Arkrypto
  link: https://github.com/Arkrypto
---

## é™æ€ä»£ç åˆ†ææ¦‚è¿°

### ä»€ä¹ˆæ˜¯ SCA

é™æ€ä»£ç åˆ†æï¼ˆStatic Code Analysisï¼‰ï¼Œæ˜¯æŒ‡åœ¨ä¸è¿è¡Œç¨‹åºçš„å‰æä¸‹ï¼Œå¯¹æºä»£ç æˆ–ä¸­é—´ä»£ç ï¼ˆå¦‚å­—èŠ‚ç ï¼‰è¿›è¡Œåˆ†æï¼Œä»¥å‘ç°æ½œåœ¨çš„é—®é¢˜ã€ç¼ºé™·ã€æ¼æ´æˆ–ä¼˜åŒ–ç‚¹

æ£€æŸ¥èŒƒå›´

| æ£€æŸ¥ç»´åº¦       | ç¤ºä¾‹                                             |
| -------------- | ------------------------------------------------ |
| âœ… è¯­æ³•é”™è¯¯     | æ‹¼å†™é”™è¯¯ã€æ¼æ‰åˆ†å·ã€ç±»å‹ä¸åŒ¹é…                   |
| âš ï¸ ä»£ç è§„èŒƒ     | å‘½åä¸è§„èŒƒã€ç¼©è¿›ä¸ç»Ÿä¸€ã€è¡Œè¿‡é•¿                   |
| ğŸ› æ½œåœ¨ bug     | ç©ºæŒ‡é’ˆã€æ•°ç»„è¶Šç•Œã€æ­»ä»£ç ã€æœªå…³é—­èµ„æº             |
| ğŸ” å®‰å…¨æ¼æ´     | SQL æ³¨å…¥ã€XSSã€è·¯å¾„éå†ã€ç¡¬ç¼–ç å¯†ç               |
| ğŸ§Š æ€§èƒ½é—®é¢˜     | é‡å¤è®¡ç®—ã€ä¸å¿…è¦å¯¹è±¡åˆ›å»º                         |
| ğŸ”§ å¯ç»´æŠ¤æ€§é—®é¢˜ | é«˜å¤æ‚åº¦ã€è¿‡æ·±åµŒå¥—ã€é•¿æ–¹æ³•ã€å¾ªç¯ä¾èµ–             |
| ğŸ¯ è®¾è®¡å±‚é¢     | ä¾èµ–åè½¬ã€è¿å SRP/OCPã€ä»£ç åå‘³é“ï¼ˆcode smellï¼‰ |

å¸¸è§çš„é™æ€åˆ†æå·¥å…·

| è¯­è¨€       | å·¥å…·                                                | ç®€ä»‹                                           |
| ---------- | --------------------------------------------------- | ---------------------------------------------- |
| Java       | âœ… [SonarQube](https://www.sonarqube.org/)           | å…¨é¢ä»£ç è´¨é‡å¹³å°ï¼ˆæ”¯æŒ Web å±•ç¤ºï¼‰              |
| Java       | [SpotBugsï¼ˆFindBugsï¼‰](https://spotbugs.github.io/) | æ£€æŸ¥å­—èŠ‚ç ï¼Œå‘ç° bug æ¨¡å¼                      |
| Java       | PMD                                                 | æ£€æŸ¥ä»£ç è§„èŒƒã€å†—ä½™ä»£ç                          |
| Java       | Checkstyle                                          | æ£€æŸ¥å‘½åã€æ ¼å¼ã€æ³¨é‡Šè§„èŒƒç­‰                     |
| Python     | pylint / flake8 / mypy                              | è¯­æ³•æ£€æŸ¥ + ç±»å‹æ£€æŸ¥                            |
| JavaScript | ESLint                                              | æœ€å¹¿æ³›ä½¿ç”¨çš„å‰ç«¯ä»£ç é™æ€åˆ†æ                   |
| C/C++      | cppcheck / clang-tidy / Coverity                    | å®‰å…¨æ¼æ´ã€å†…å­˜é”™è¯¯åˆ†æ                         |
| å¤šè¯­è¨€     | [Semgrep](https://semgrep.dev/)                     | æ”¯æŒæ¨¡å¼åŒ¹é…å¼å®‰å…¨è§„åˆ™ï¼Œå¯è‡ªå®šä¹‰               |
| å¤šè¯­è¨€     | CodeQLï¼ˆGitHubï¼‰                                    | ç±»ä¼¼ SQL çš„ä»£ç æŸ¥è¯¢è¯­è¨€ï¼ŒGitHub Actions å¯é›†æˆ |

### å¸¸è§åœºæ™¯

åœ¨ CI/CD æµç¨‹ä¸­è¿›è¡Œä»£ç å®¡æŸ¥ï¼Œä¾‹å¦‚ä½¿ç”¨ GitHubã€GitLabã€Jenkinsï¼Œå°†åˆ†æå·¥å…·**é›†æˆè¿›ä½ çš„ä»£ç æäº¤æˆ– PR æµç¨‹ä¸­**ï¼Œè®©æ¯æ¬¡ push éƒ½è‡ªåŠ¨æ£€æŸ¥ä»£ç è´¨é‡å’Œå®‰å…¨æ€§

å®‰å…¨æ‰«æç±»åº“

- SonarQube å®‰å…¨è§„åˆ™é›†
- Semgrep å®‰å…¨è§„åˆ™åº“
- CodeQLï¼šGitHub å®˜æ–¹æ¨èï¼Œç”¨äºæŸ¥æ‰¾é€»è¾‘å‹å®‰å…¨é—®é¢˜ï¼ˆå¦‚è®¿é—®æ§åˆ¶ç¼ºå¤±ã€æ³¨å…¥æ¼æ´ï¼‰

é›†æˆ SonarQube

- åœ¨æœ¬åœ°æˆ– CI/CD ä¸­éƒ¨ç½² SonarQube Server
- ä½¿ç”¨`sonar-scanner`æˆ– Maven æ’ä»¶ä¸Šä¼ ä»£ç åˆ†æç»“æœ
- å¯é€šè¿‡æµè§ˆå™¨æŸ¥çœ‹ï¼šbugsã€code smellsã€å®‰å…¨æ¼æ´ã€é‡å¤ä»£ç ç­‰

æˆ–è€…åœ¨å¼€å‘è¿‡ç¨‹ä¸­ä½¿ç”¨æ’ä»¶è¿›è¡Œä»£ç æ£€æŸ¥

| å·¥å…·       | é›†æˆæ–¹å¼                                |
| ---------- | --------------------------------------- |
| Checkstyle | IDE æ’ä»¶æˆ– Maven æ’ä»¶ï¼ˆè‡ªåŠ¨ fail æ„å»ºï¼‰ |
| SpotBugs   | Maven æ’ä»¶ / Gradle æ’ä»¶                |
| PMD        | IDE æ’ä»¶æˆ–`mvn pmd:check`               |

### åˆ†æçš„åº•å±‚é€»è¾‘

é™æ€åˆ†æçš„åº•å±‚ï¼Œå…¶å®å°±åƒç¼–è¯‘å™¨çš„å‰ç«¯ï¼ˆè¯­æ³•åˆ†æ âœ æŠ½è±¡è¯­æ³•æ ‘ âœ è¯­ä¹‰æ£€æŸ¥ âœ æµç¨‹åˆ†æï¼‰

```
æºä»£ç 
  â†“
è¯æ³•åˆ†æï¼ˆLexerï¼‰
  â†“
è¯­æ³•åˆ†æï¼ˆParserï¼‰â†’ æŠ½è±¡è¯­æ³•æ ‘ AST
  â†“
è¯­ä¹‰åˆ†æï¼ˆç±»å‹æ¨æ–­ã€ç¬¦å·ç»‘å®šï¼‰
  â†“
æ§åˆ¶æµåˆ†æï¼ˆCFAï¼‰& æ•°æ®æµåˆ†æï¼ˆDFAï¼‰
  â†“
è§„åˆ™åŒ¹é…ï¼ˆLintï¼‰æˆ–æ¨¡å¼åŒ¹é…ï¼ˆå¦‚ Semgrepã€CodeQLï¼‰
  â†“
è¾“å‡ºè­¦å‘Š / é”™è¯¯ / æŠ¥å‘Š
```

1ï¸âƒ£ è¯æ³•åˆ†æï¼ˆLexical Analysisï¼‰

æŠŠæºç åˆ†å‰²æˆä¸€ä¸² tokenï¼ˆå…³é”®è¯ã€æ ‡è¯†ç¬¦ã€æ‹¬å·ã€åˆ†å·ç­‰ï¼‰ï¼Œä¾‹å¦‚

```java
int x = 5;
```

ä¼šè¢«åˆ†å‰²æˆï¼š`int`, `x`, `=`, `5`, `;`

2ï¸âƒ£ è¯­æ³•åˆ†æï¼ˆSyntax Analysisï¼‰

- åŸºäºä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ï¼ˆCFGï¼‰ï¼Œå°† token ç»“æ„åŒ–æˆæŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰
- AST æ˜¯â€œæºä»£ç çš„ç»“æ„è¡¨ç¤ºâ€ï¼Œä¹Ÿæ˜¯å¤§éƒ¨åˆ†é™æ€åˆ†æçš„æ ¸å¿ƒå…¥å£

ä¾‹å¦‚ä»£ç ï¼š`if (x > 0) y = 1;`ï¼‰

```java
IfStatement
 â”œâ”€ Condition: BinaryExpr (x > 0)
 â””â”€ Then: AssignExpr (y = 1)
```

å·¥å…·å¦‚ ESLintã€Checkstyleã€PMDã€SpotBugs éƒ½ä¼šç”¨ AST

3ï¸âƒ£ è¯­ä¹‰åˆ†æï¼ˆSemantic Analysisï¼‰

æ£€æŸ¥å˜é‡ç±»å‹ã€ä½œç”¨åŸŸã€æ˜¯å¦å®šä¹‰ã€è°ƒç”¨åˆæ³•æ€§ç­‰ï¼Œä¾‹å¦‚

```java
x = y + 1;  // å¦‚æœ y æ²¡æœ‰å®šä¹‰ï¼ŒæŠ¥é”™
```

4ï¸âƒ£ æ§åˆ¶æµåˆ†æï¼ˆControl Flow Analysis, CFAï¼‰

- æ„å»ºæ§åˆ¶æµç¨‹å›¾ï¼ˆCFGï¼‰ï¼Œåˆ†ææ¡ä»¶/å¾ªç¯/åˆ†æ”¯/è·³è½¬
- ç”¨æ¥åˆ¤æ–­ä»£ç æ˜¯å¦å¯è¾¾ã€åˆ†æ”¯è¦†ç›–æ˜¯å¦å®Œæ•´ç­‰

å›¾ç¤º

```css
[Start]
   â†“
[x > 0] â”€ Yes â†’ [doSomething()]
   â””â”€ No â†’ [return]
```

5ï¸âƒ£ æ•°æ®æµåˆ†æï¼ˆData Flow Analysis, DFAï¼‰

- åˆ†æå˜é‡çš„å®šä¹‰-ä½¿ç”¨é“¾ã€æ˜¯å¦åˆå§‹åŒ–ã€æ˜¯å¦ä¸ºç©ºç­‰
- ä¸¾ä¾‹ï¼šç©ºæŒ‡é’ˆåˆ†æã€èµ„æºæœªå…³é—­ã€å˜é‡æœªèµ‹å€¼å°±ä½¿ç”¨ç­‰ï¼ŒSpotBugs ç­‰å·¥å…·å¹¿æ³›åº”ç”¨

6ï¸âƒ£ è§„åˆ™åŒ¹é… / æ¨¡å¼è¯†åˆ«ï¼ˆPattern Matchingï¼‰

- ä½¿ç”¨é¢„å®šä¹‰æˆ–ç”¨æˆ·è‡ªå®šä¹‰çš„è§„åˆ™é›†æ¥åŒ¹é…ä»£ç ç»“æ„
- å¦‚ Checkstyle ä¼šæ£€æŸ¥ `class å‘½åå¿…é¡»å¤§å†™å¼€å¤´`ï¼ŒPMD ä¼šåŒ¹é… `== null` çš„ä»£ç å—
- Semgrep/CodeQL æ›´å¼ºï¼Œå®ƒå¯ä»¥åŒ¹é…ç»“æ„+ä¸Šä¸‹æ–‡

```yaml
rules:
  - id: detect-hardcoded-password
    pattern: |
      password = "..."
```

æ¨¡å¼åŒ¹é… + AST å¯¼èˆªæ˜¯ç°ä»£åˆ†æå·¥å…·ï¼ˆå¦‚ Semgrepã€CodeQLï¼‰çš„é‡è¦ç‰¹æ€§

ä¸€äº›æ›´æ™ºèƒ½çš„æ–¹æ³•

| æ–¹æ³•                                | è¯´æ˜                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| ç¬¦å·æ‰§è¡Œï¼ˆSymbolic Executionï¼‰      | æŠŠå˜é‡å½“æˆç¬¦å·è€Œä¸æ˜¯å…·ä½“å€¼è¿›è¡Œé€»è¾‘æ¨æ¼”ï¼Œç”¨äºè·¯å¾„è¦†ç›–         |
| æŠ½è±¡è§£é‡Šï¼ˆAbstract Interpretationï¼‰ | å¯¹ç¨‹åºæ‰§è¡Œè¿›è¡Œè¿‘ä¼¼å»ºæ¨¡ï¼Œä¿å®ˆåœ°å‘ç°é—®é¢˜                       |
| æ¨¡å‹æ£€æµ‹ï¼ˆModel Checkingï¼‰          | å»ºæ¨¡ç¨‹åºçŠ¶æ€æœºï¼ŒéªŒè¯å…¶æ˜¯å¦æ»¡è¶³è§„èŒƒï¼ˆå¦‚æ­»é”ï¼‰                 |
| äººå·¥æ™ºèƒ½è¾…åŠ©åˆ†æ                    | ç»“åˆè¯­è¨€æ¨¡å‹ï¼Œè‡ªåŠ¨ä¿®å¤è­¦å‘Šæˆ–ç”Ÿæˆè§„åˆ™ï¼ˆGitHub Copilot + CodeQLï¼‰ |

### Java è¯æ³•åˆ†æå™¨

åŸºäº Java å®ç°ï¼Œå‚è€ƒ

- [Javaè¯­è¨€çš„è¯æ³•åˆ†æå™¨çš„Javaå®ç° - daheww - åšå®¢å›­](https://www.cnblogs.com/daheww/p/13873618.html)
- [è¯æ³•å’Œè¯­æ³•åˆ†æå™¨è®¾è®¡ | Arkrypto](http://arkrypto.github.io/pages/c78d5b/#è¯æ³•åˆ†æå™¨-lexer)

ä¿ç•™å…³é”®å­—

```java
public class Lexical {
    private static final String reserveWords[] = { "abstract", "boolean", "break", "byte", "case", "catch", "char", "class", "continue", "default", "do", "double", "else", "extends", "final", "finally", "float", "for", "if", "implements", "import", "instanceof", "int", "interface", "long", "native", "new", "package", "private", "protected", "public", "return", "short", "static", "super", "switch", "synchronized", "this", "throw", "throws", "transient", "try", "void", "volatile", "while", "strictfp", "enum", "goto", "const", "assert"     }; // 50
}
```

åˆå§‹åŒ–ä»¥åŠæ„é€ å‡½æ•°

```java
public class Lexical {
    private BufferedReader fd;
    private int state; // å½“å‰çŠ¶æ€
    private char ch; // å½“å‰å­—ç¬¦
    private String info; // ç»“æœä¸²
    private String temp; // ä¸´æ—¶å­˜å‚¨
    int lineNum; // å½“å‰ä»£ç è¡Œæ•°
    boolean finished; // åˆ¤æ–­æ–‡ä»¶æ˜¯å¦è¯»å®Œ
    
    public Lexical() {
        info = "";
        temp = "";
        lineNum = 1;
        finished = false;
        getChar();
        analyze(); // åˆ†æ
        write(info); // è¾“å‡º
    }
}
```

è¾“å…¥è¾“å‡ºï¼ŒçŠ¶æ€è½¬ç§»

```java
private void getChar() {
    try {
        if (fd == null) {
            ClassPathResource resource = new ClassPathResource("test.txt");
            fd = new BufferedReader(new InputStreamReader(resource.getInputStream()));
        }
        int end = fd.read();
        if (end == -1) { // å½“ä»ä¸€ä¸ªæ–‡ä»¶ä¸­è¯»å–æ•°æ®æ—¶ï¼Œåœ¨æ•°æ®æœ€åä¼šè¿”å›ä¸€ä¸ªintå‹-1æ¥è¡¨ç¤ºç»“æŸ
            fd.close();
            finished = true;
            return;
        }
        ch = (char) end;
    } catch (IOException e) {
        e.printStackTrace();
    }
}

private void toNextCharAndChangeState(int state) {
    this.state = state;
    getChar();
}

private void toNextCharAndStoreTempAndChangeState(int state) {
    temp += ch;
    this.state = state;
    getChar();
}

private void writeInfo(String value, String type) {
    info += lineNum + ": < " + type + " , " + value + " >;\r\n";
    state = 0;
}

private void write(String info) {
    try {
        FileWriter fw = new FileWriter("result.txt");
        fw.write(info);
        fw.flush(); // åˆ·æ–°æ•°æ®ï¼Œå°†æ•°æ®å†™å…¥æ–‡ä»¶ä¸­
        fw.close();
    } catch (IOException e) {
        e.printStackTrace();
    }
}

private void error(int i) {
    info = "è¯æ³•åˆ†æå‡ºé”™\r\né”™è¯¯å®šä½ï¼š" + i;
}
```

ä¸€äº›è¾…åŠ©çš„åˆ¤æ–­å‡½æ•°

```java
private boolean isReserve(String temp2) {
    for (int i = 0; i < 50; i++) {
        if (temp.equals(reserveWords[i])) {
            return true;
        }
    }
    return false;
}

private boolean isLegalChar(String temp) {
    char[] ch = temp.toCharArray();
    int length = ch.length;
    boolean isLegalChar = false;
    
    if (length == 2) { // ''
        isLegalChar = false;
    } else if (length == 3) {
        isLegalChar = true;
    } else if (length == 4) {
        if ((ch[1] == '\\') && (ch[2] == 'b' || ch[2] == 'n' || ch[2] == 'r' || ch[2] == 't' || ch[2] == '\"'
                                || ch[2] == '\'' || ch[2] == '\\' || isDigital(ch[2]))) {
            isLegalChar = true;
        }
    } else if (length <= 6) {
        if (ch[1] == '\\') {
            for (int i = 2; i < (length - 1); i++) {
                if (!isDigital(ch[i])) {
                    isLegalChar = false;
                    break;
                }
                isLegalChar = true;
            }
        } else {
            System.out.println('*');
            isLegalChar = false;
        }
    } else {
        isLegalChar = false;
    }

    return isLegalChar;
}

private boolean isLetter(char ch) {
    return (ch >= 65 && ch <= 90) || (ch >= 97 && ch <= 122);
}

private boolean isBoundary(char ch) {
    return ch == ',' || ch == ';' || ch == '(' || ch == ')' || ch == '[' || ch == ']' || ch == '{' || ch == '}';
}

private boolean isOperator1(char ch) { // / * = &lt; &gt;
    return ch == '/' || ch == '*' || ch == '=' || ch == '<' || ch == '>';
}

private boolean isOperator2(char ch) { // ? . :
    return ch == '?' || ch == '.' || ch == ':';
}

private boolean isDigital(char ch) {
    return ch >= 48 && ch <= 57;
}
```

analyze å‡½æ•°ï¼šæ¯æ¬¡å¤„ç†ä¸€ä¸ªå­—ç¬¦

```java
private void analyze() {

    if (finished && temp.equals(""))
        return; // å·²ç»è¯»å–åˆ°æœ€åä¸€ä¸ªå­—ç¬¦ï¼Œä¸”æ²¡æœ‰å¾…å¤„ç†å­—ç¬¦
    if (ch == '\n')
        lineNum++;

    switch (state) {
        case 0 -> {
            temp = "";
            if (ch == ' ' || ch == '\r' || ch == '\t' || ch == '\n') {
                toNextCharAndChangeState(0);
            } else if (ch == '/') {
                toNextCharAndStoreTempAndChangeState(1);
            } else if (isDigital(ch)) {
                toNextCharAndStoreTempAndChangeState(5);
            } else if (isOperator1(ch)) {
                toNextCharAndStoreTempAndChangeState(8);
            } else if (ch == '!') {
                toNextCharAndStoreTempAndChangeState(9);
            } else if (isOperator2(ch)) {
                writeInfo((ch + ""), "è¿ç®—ç¬¦");
                getChar();
            } else if (isBoundary(ch)) {
                writeInfo((ch + ""), "ç•Œç¬¦");
                getChar();
            } else if (ch == '"') {
                toNextCharAndStoreTempAndChangeState(10);
            } else if (isLetter(ch)) {
                toNextCharAndStoreTempAndChangeState(11);
            } else if (ch == '\'') {
                toNextCharAndStoreTempAndChangeState(14);
            } else if (ch == '-' || ch == '+') {
                toNextCharAndStoreTempAndChangeState(16);
            } else if (ch == '|') {
                toNextCharAndStoreTempAndChangeState(17);
            } else if (ch == '&') {
                toNextCharAndStoreTempAndChangeState(18);
            } else if (ch == (char) -1) {
                // ç¨‹åºåº”è¯¥ç»“æŸ
                return;
            } else { // éæ³•å­—ç¬¦
                error(1);
                return;
            }
        }
        case 1 -> {
            if (ch == '/') {
                toNextCharAndChangeState(2);
            } else if (ch == '*') {
                toNextCharAndChangeState(3);
            } else {
                state = 8;
            }
        }
        case 2 -> { // å¤„ç†æ³¨é‡Š
            if (ch == '\n') {
                state = 0;
                getChar();
            } else {
                getChar();
            }
        }
        case 3 -> { // å¤„ç†æ³¨é‡Š
            if (ch == '*') {
                toNextCharAndChangeState(4);
            } else {
                getChar();
            }
        }
        case 4 -> { // å¤„ç†æ³¨é‡Š
            if (ch == '/') {
                toNextCharAndChangeState(0);
            } else {
                toNextCharAndChangeState(3);
            }
        }
        case 5 -> {
            if (isDigital(ch)) {
                temp += ch;
                getChar();
            } else {
                state = 6;
            }
        }
        case 6 -> {
            if (ch == '.') {
                toNextCharAndStoreTempAndChangeState(7);
            } else {
                writeInfo(temp, "å¸¸æ•°");
            }
        }
        case 7 -> {
            if (isDigital(ch)) {
                toNextCharAndStoreTempAndChangeState(13);
            } else {
                error(4);
                return;
            }
        }
        case 8 -> {
            if (ch == '=') {
                temp += ch;
                writeInfo(temp, "è¿ç®—ç¬¦");
                getChar();
            } else {
                writeInfo(temp, "è¿ç®—ç¬¦");
            }
        }
        case 9 -> {
            if (ch == '=') {
                temp += ch;
                writeInfo(temp, "è¿ç®—ç¬¦");
                getChar();
            } else {
                error(2);
                return;
            }
        }
        case 10 -> {
            if (ch == '"') {
                temp += ch;
                writeInfo(temp, "å¸¸é‡");
                getChar();
            } else if (ch == '\\') {
                for (int i = 0; i < 2 ; i++){
                    temp += ch;
                    getChar();
                }
                state = 10;
            } else {
                toNextCharAndStoreTempAndChangeState(10);
            }
        } case 11 -> {
            if (isDigital(ch) || isLetter(ch) || ch == '_') {
                toNextCharAndStoreTempAndChangeState(11);
            } else {
                state = 12;
            }
        }
        case 12 -> {
            if (isReserve(temp)) {
                writeInfo(temp, "ä¿ç•™å­—");
                getChar();
            } else {
                writeInfo(temp, "æ ‡è¯†ç¬¦");
                getChar();
            }
        }
        case 13 -> {
            if (isDigital(ch)) {
                toNextCharAndStoreTempAndChangeState(13);
            } else {
                writeInfo(temp, "å¸¸æ•°");
            }
        }
        case 14 -> {
            if (ch == '\'') {
                temp += ch;
                if (isLegalChar(temp)) {
                    writeInfo(temp, "å¸¸é‡");
                } else {
                    error(9);
                    return;
                }
                getChar();
            } else if (ch == '\\') {
                for (int i = 0; i < 2; i++){
                    temp += ch;
                    getChar();
                }
                state = 14;
            } else {
                toNextCharAndStoreTempAndChangeState(14);
            }
        } case 16 -> {
            if (isDigital(ch)) {
                toNextCharAndStoreTempAndChangeState(5);
            } else {
                state = 8;
            }
        }
        case 17 -> {
            if (ch == '|') {
                temp += ch;
                writeInfo(temp, "è¿ç®—ç¬¦");
                getChar();
            } else {
                writeInfo(temp, "è¿ç®—ç¬¦");
            }
        }
        case 18 -> {
            if (ch == '&') {
                temp += ch;
                writeInfo(temp, "è¿ç®—ç¬¦");
                getChar();
            } else {
                writeInfo(temp, "è¿ç®—ç¬¦");
            }
        }
        default -> {
            error(3);
            return;
        }
    }

    analyze(); // é‡å¤è°ƒç”¨
}
```

ä¸»å‡½æ•°

```java
public class Lexical {
    public static void main(String[] args) throws IOException {
        new Lexical();
    }
}
```

æµ‹è¯•è¾“å…¥

```java
private boolean isReserve(String temp2) {
    for (int i = 0; i < 50; i++) {
        if (temp.equals(reserveWords[i])) {
            return true;
        }
    }
    return false;
}
```

è¾“å‡º

```
1: < ä¿ç•™å­— , private >;
1: < ä¿ç•™å­— , boolean >;
1: < æ ‡è¯†ç¬¦ , isReserve >;
1: < æ ‡è¯†ç¬¦ , String >;
1: < æ ‡è¯†ç¬¦ , temp2 >;
1: < ç•Œç¬¦ , { >;
2: < ä¿ç•™å­— , for >;
2: < ç•Œç¬¦ , ( >;
2: < ä¿ç•™å­— , int >;
2: < æ ‡è¯†ç¬¦ , i >;
2: < è¿ç®—ç¬¦ , = >;
2: < å¸¸æ•° , 0 >;
2: < ç•Œç¬¦ , ; >;
2: < æ ‡è¯†ç¬¦ , i >;
2: < è¿ç®—ç¬¦ , < >;
2: < å¸¸æ•° , 50 >;
2: < ç•Œç¬¦ , ; >;
2: < æ ‡è¯†ç¬¦ , i >;
2: < è¿ç®—ç¬¦ , + >;
2: < ç•Œç¬¦ , ) >;
2: < ç•Œç¬¦ , { >;
3: < ä¿ç•™å­— , if >;
3: < ç•Œç¬¦ , ( >;
3: < æ ‡è¯†ç¬¦ , temp >;
3: < æ ‡è¯†ç¬¦ , equals >;
3: < æ ‡è¯†ç¬¦ , reserveWords >;
3: < æ ‡è¯†ç¬¦ , i >;
3: < ç•Œç¬¦ , ) >;
3: < ç•Œç¬¦ , ) >;
3: < ç•Œç¬¦ , { >;
4: < ä¿ç•™å­— , return >;
4: < æ ‡è¯†ç¬¦ , true >;
5: < ç•Œç¬¦ , } >;
6: < ç•Œç¬¦ , } >;
7: < ä¿ç•™å­— , return >;
7: < æ ‡è¯†ç¬¦ , false >;
8: < ç•Œç¬¦ , } >;
```

## åç«¯ä»£ç åˆ†æç±»åº“

è€ƒè™‘è¿™æ ·ä¸€ä¸ªåœºæ™¯ï¼šå¯¹äºä¸€ä¸ªå®Œæ•´çš„ Spring é¡¹ç›®ï¼Œæˆ‘éœ€è¦æŒ‰ç…§æ¥å£ï¼ŒæŠ½ä¸å‰¥èŒ§èˆ¬æŠŠæ¯ä¸ª API çš„åº•å±‚è°ƒç”¨æ•´ç†æˆä¸€ä¸ªå®Œæ•´çš„ä¾èµ–é“¾è·¯ï¼Œè€Œåå°†æ¯æ¡é“¾è·¯ä»¥åŠç›¸å…³çš„æºç æ‰”ç»™å¤§æ¨¡å‹è¿›è¡Œå®‰å…¨æ€§åˆ†æ

é—®é¢˜çš„å…³é”®åœ¨äºï¼šå¦‚ä½•æ„å»ºæ¯ä¸ª API è°ƒç”¨çš„ä¾èµ–è·¯å¾„ä»¥åŠå¦‚ä½•æ•´ç†æ¯æ¡è·¯å¾„ä¸Šçš„ç›¸å…³ä»£ç 

### Java Parser

è¯­æ³•åŠè¯­ä¹‰åˆ†æ

- [JavaParser - Home](https://javaparser.org/)
- [javaparser/javaparser: Java 1-21 Parser and Abstract Syntax Tree for Java with advanced analysis functionalities.](https://github.com/javaparser/javaparser)

æ ¸å¿ƒåº“åŠåŠŸèƒ½

| åç§°                 | åŠŸèƒ½                                                         |
| -------------------- | ------------------------------------------------------------ |
| `JavaParser`         | è¯­æ³•åˆ†æå™¨ï¼Œæ„å»º Java æºç çš„ AST                             |
| `JavaSymbolSolver`   | åšé™æ€ç¬¦å·è§£æï¼ˆå˜é‡ã€æ–¹æ³•ã€ç±»ä¹‹é—´çš„å¼•ç”¨å…³ç³»ï¼‰ï¼ŒåŸºäºç±»å‹ä¿¡æ¯è§£ææ–¹æ³•è°ƒç”¨ã€å˜é‡å¼•ç”¨ç­‰ |
| `CombinedTypeSolver` | æä¾›ç±»è·¯å¾„ä¸Šçš„ç±»å‹ä¿¡æ¯ï¼ˆåŒ…æ‹¬ JREã€é¡¹ç›®æºç ã€ä¾èµ– jarï¼‰       |

Maven å¼•å…¥

```xml
<dependency>
    <groupId>com.github.javaparser</groupId>
    <artifactId>javaparser-symbol-solver-core</artifactId>
    <version>3.25.5</version>
</dependency>
```

ProjectAnalyzerï¼šåˆ†æä¸€ä¸ªç›®å½•ä¸‹çš„æ‰€æœ‰ Java ä»£ç ï¼Œè®°å½•å„è‡ªçš„è¯­æ³•æ ‘

```java
public class ProjectAnalyzer {
    
    private Map<String, String> pathToSource = new HashMap<>();
    private Map<String, CompilationUnit> pathToAst = new HashMap<>();

    public void analyzeDirectory(File root) {
        File[] files = root.listFiles(f -> f.getName().endsWith(".java"));
        if (files == null) return;

        for (File file : files) {
            try {
                String content = Files.readString(file.toPath());
                pathToSource.put(file.getAbsolutePath(), content);
                CompilationUnit cu = StaticJavaParser.parse(content);
                pathToAst.put(file.getAbsolutePath(), cu);
            } catch (Exception e) {
                System.err.println("Error parsing " + file.getName());
            }
        }
    }

    public Map<String, CompilationUnit> getAstMap() {
        return pathToAst;
    }

    public Map<String, String> getSourceMap() {
        return pathToSource;
    }
}
```

JsonGeneratorï¼šå°† ProjectAnalyzer çš„ AST è®°å½•è½¬åŒ–ä¸º String ç±»å‹çš„ Json æ•°æ®

æˆ‘ä»¬æƒ³è·å¾—çš„æ•°æ®ç»“æ„

```java
public class MethodInfo {
    public String methodName;
    public String returnType;
    public List<String> parameters;
    public List<String> calls = new ArrayList<>();
}

public class ClassInfo {
    public String className;
    public List<MethodInfo> methods = new ArrayList<>();
}

```

åœ¨éå† AST çš„åŒæ—¶è·å–ä¿¡æ¯

```java
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.*;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.util.*;

public class JsonGenerator {

    private final Map<String, CompilationUnit> pathToAst;

    public JsonGenerator(Map<String, CompilationUnit> pathToAst) {
        this.pathToAst = pathToAst;
    }

    public String generateJson() {
        Map<String, Object> output = new HashMap<>();

        for (Map.Entry<String, CompilationUnit> entry : pathToAst.entrySet()) {
            String filePath = entry.getKey();
            CompilationUnit cu = entry.getValue();

            List<ClassInfo> classInfos = new ArrayList<>();

            for (TypeDeclaration<?> type : cu.getTypes()) {
                if (type.isClassOrInterfaceDeclaration()) {
                    ClassOrInterfaceDeclaration clazz = (ClassOrInterfaceDeclaration) type;

                    ClassInfo classInfo = new ClassInfo();
                    classInfo.className = clazz.getNameAsString();

                    for (MethodDeclaration method : clazz.getMethods()) {
                        MethodInfo methodInfo = new MethodInfo();
                        methodInfo.methodName = method.getNameAsString();
                        methodInfo.returnType = method.getTypeAsString();
                        methodInfo.parameters = method.getParameters().stream()
                            .map(p -> p.getTypeAsString() + " " + p.getNameAsString())
                            .toList();

                        // ğŸ‘‡ æå–è°ƒç”¨çš„æ–¹æ³•
                        method.findAll(MethodCallExpr.class).forEach(call -> {
                            methodInfo.calls.add(call.getNameAsString());
                        });

                        classInfo.methods.add(methodInfo);
                    }

                    classInfos.add(classInfo);
                }
            }

            output.put(filePath, classInfos);
        }

        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        return gson.toJson(output);
    }
}
```

### Language Server

Eclipse JDT Language Server

- [eclipse-jdtls/eclipse.jdt.ls: Java language server](https://github.com/eclipse-jdtls/eclipse.jdt.ls)
- [Eclipse JDT Language Server - manateelazycat/lsp-bridge GitHub Wiki](https://github-wiki-see.page/m/manateelazycat/lsp-bridge/wiki/Eclipse-JDT-Language-Server)

æˆ‘ä¹‹å‰æƒ³çš„æ˜¯ï¼Œè°ƒæ•´ LS å¯¹æºç è¿›è¡Œç»Ÿä¸€æ ‡å‡†åŒ–çš„å¤„ç†ï¼Œè¾“å‡º JSON æ•°æ®ï¼Œå†ä¸€è‚¡è„‘ä¸¢ç»™ LLM åˆ†æ

- å³ç”¨æˆ·ä½œä¸º LS çš„ Client
- è¿™æ ·æˆ‘çš„è°ƒç”¨å…³ç³»æ˜¯ï¼šç”¨æˆ· â†’ LS â†’ LLM â†’ ç”¨æˆ·

é¾™å¯¼çš„æ„æ€æ˜¯ï¼Œè®© LLM ä½œä¸ºä¸€ä¸ªç‹¬ç«‹å®¢ä½“ï¼Œé€šè¿‡ CMP è°ƒç”¨ LS è¾¹åˆ†æè¾¹è¿½æº¯

- ç­‰äºç°åœ¨å˜æˆäº†ï¼šç”¨æˆ· â†’ LLM â†” LS â†’ ç”¨æˆ·
- æ­¤æ—¶ LLM å˜æˆäº† LS çš„ Clientï¼Œå½“ç„¶è¿™é‡Œå®é™…çš„ Client æ˜¯ LLM è°ƒç”¨çš„ MCP å®¢ä½“

æˆ‘ç›´æ¥å°†æºç ä¸¢ç»™ LLMï¼ŒLLM ä»æ ¹èŠ‚ç‚¹å¼€å§‹åˆ†æï¼Œåˆ†æåˆ°åº•å±‚çš„æ–¹æ³•æ—¶ï¼Œé‡‡ç”¨ MCP å¯¹ LS è¿›è¡Œè°ƒç”¨ï¼Œè¿”å›å¯¹åº”çš„æ–¹æ³•åå’Œæºç ï¼Œç„¶åç›´æ¥è·³åˆ°é‚£ä¸€æ®µä»£ç æ¥ç€åˆ†æï¼Œè¿™æ ·ä¼šå¤§å¤§æå‡ LLM çš„å‡†åº¦å’Œæ•ˆç‡

## Spring MCP æœåŠ¡æ„å»º

### Spring AI



### MCP Server



### MCP Client
