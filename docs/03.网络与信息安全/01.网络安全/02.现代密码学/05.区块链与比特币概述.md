---
date: 2025-5-19
author: 
  name: Arkrypto
  link: https://github.com/Arkrypto
title: 区块链与比特币概述
permalink: /pages/7d74ca/
---

## 区块链

> Blockchain

区块链（Blockchain）是一种**去中心化的分布式账本技术**，最初被用于比特币，现在被广泛应用于金融、供应链、身份认证、医疗等领域

- Block（区块）：指的是交易数据被打包后形成的单元
- Chain（链）：指的是这些区块按时间顺序通过加密链接在一起，形成一条链式结构

区块链本质上是一个由多个“区块”**按时间顺序**串联组成的数据结构，每个区块中记录了**一组**交易数据，并通过密码学方法保证不可篡改

- 就是一个链表，只不过节点数据很特别

**每个区块中不仅包含交易数据，还包含前一个区块的哈希值（加密摘要），从而形成一个前后相连、不可逆的链式结构，一旦前面的区块内容被修改，其后的所有区块的哈希也会发生变化，因此可以有效防止数据篡改**

它具有以下几个核心特性

| 特性             | 解释                                                   |
| ---------------- | ------------------------------------------------------ |
| 分布式           | 数据不是集中在一个服务器上，而是存储在网络中所有节点中 |
| 去中心化         | 不依赖任何单一机构或第三方，节点间通过共识机制达成一致 |
| 不可篡改         | 一旦数据被记录到区块链上就无法更改                     |
| 可追溯性         | 每笔交易都有完整的时间戳和历史记录                     |
| 透明性和可验证性 | 所有节点都能验证交易的真实性和完整性                   |

可以将区块链比作一本多人共享的“记账本”，每一页就是一个区块，每页内容写好后都**盖章封存**（哈希+共识机制），然后连接到前一页之后，所有人都能看到记账内容，但没人能偷偷改动过去的记录（这样将失去有效性）

### 哈希与共识机制

我们把每个**区块**看作一本“账簿页面”

- 上面写着本轮的交易记录
- 为了防止事后修改，系统要给它盖章封存

这个“封存”过程由两部分组成

| 组成               | 含义                                     | 作用                                     |
| ------------------ | ---------------------------------------- | ---------------------------------------- |
| 哈希（Hash）       | 用加密算法把区块“压缩”为一个唯一摘要值   | 一旦数据改动，哈希值就会改变，能立刻察觉 |
| 共识机制（如 PoW） | 网络中大多数节点**共同同意**这个区块有效 | 防止恶意节点随意造假                     |

哈希 = 在每页账簿上盖防伪印章

在区块链中

- 每个区块都记录前一个区块的哈希值
- 区块内容一改，哈希就变，链就断了
- 这使得任何人想修改历史记录都变得几乎不可能

哈希保证了“区块内部”和“区块之间”都不能被偷偷篡改，我们可以保证任意一个链的合法性，并且链上的区块可以通过摘要值保证其无法篡改

区块的合法性如何保证？用到共识机制

| 机制                        | 说明                                           |
| --------------------------- | ---------------------------------------------- |
| 工作量证明（Proof of Work） | 比特币使用，必须算出一个符合条件的哈希（很难） |
| 权益证明（PoS）             | 以太坊等使用，凭“持币量”投票决策               |
| 拜占庭容错、DPoS、PBFT 等   | 其他公链/联盟链使用                            |

共识 = 众人见证并盖公章，谁造假就会被识破

在比特币中

- 谁想添加新区块，必须算出一个合格哈希（挖矿）
- 这非常耗费计算力，意味着这个“封章”具有“成本”
- 网络只接受**最长合法链**作为真正的“账本”

共识机制保证了大家都接受同一个历史，不会有“分叉账本”乱象

区块链的安全与可信，来源于哈希算法提供的防篡改能力和共识机制提供的集体认可，这套机制就是区块链最本质的盖章封存

### 最长合法链

什么叫“最长合法链”？在比特币系统中

- 每一个新区块都是接在上一个合法区块后面
- 这样连接形成了一个链条，称为“区块链”
- 不同的矿工可能同时挖出不同的新块，就可能出现分叉
- 比特币规定： “ 以工作量为准，链上块最多的那条链为主链”

所以，“最长合法链”意思是：**目前全网算力共同认定的、累计工作量最大的那条区块链**，即所有节点都认为是“正统”的链，即唯一的**账本**

为什么叫“最长”？这指的是什么长度？不是指字节数或块个数，而是指“累积的工作量（难度）

- 在比特币中，每个区块都必须经过挖矿计算（工作量证明，PoW）
- 你挖得越多、链越长，就代表你为这条链投入了更多计算资源
- 网络规定：谁的链累积的工作量最多，谁的链就被视为“主链”
- 这通常表现为块数最多的一条链，因为每个块的难度是固定的

举个例子，假设区块链已经走到第 100 个区块，某一时刻，两个矿工同时挖出了第 101 块，分别叫`101A`和`101B`，网络产生了“短暂分叉”

```
... → 100 → 101A  
          ↘︎ 101B
```

此时，有的节点收到`101A`，有的收到`101B`，网络短暂不一致，假如接下来矿工 C 在`101A`的基础上成功挖出`102A`，链就变成

```
... → 100 → 101A → 102A  
          ↘︎ 101B
```

这时，“A链”更长了，大多数节点就会选择它，那么最长合法链 = ... → 100 → 101A → 102A

而`101B`和其交易就会被丢弃，称为“孤块（orphan block）”

- 需要注意的是，`101B`本身是一个合法的区块（他正确引用了上一个区块 100 的哈希并且工作量证明 PoW 达标），但是不是一个合法的比特币，因为这笔帐被主链抛弃了

最长合法链解决了什么问题？它是去中心化世界中解决冲突、达成共识的方式

- 没有中央服务器说了算
- 所有节点都用相同规则判断哪条链是主链
- 就算发生了分叉，大家也知道： “我们跟着最长合法链走”，这就避免了混乱

## 比特币

> Bitcoin

比特币（Bitcoin）是**第一个**真正实现的区块链应用，它是一种去中心化的**数字加密货币**，由中本聪（Satoshi Nakamoto）在 2008 年提出，2009 年正式发布

### 区块链应用

1️⃣ 交易打包成区块

- 用户发起交易（例如 A 给 B 转 1 个比特币）
- 网络节点广播这笔交易
- “矿工”收集一批交易并打包成一个区块（block）

2️⃣ 工作量证明（PoW）机制：挖矿

- 为了添加这个新区块，矿工必须完成一个复杂的数学难题（找一个满足条件的哈希值）
- 这个过程称为“挖矿”，谁先解出问题，谁就能把区块加到区块链上，并获得**比特币奖励**

3️⃣ 区块链接成链

- 每个新区块中记录上一个区块的哈希值
- 形成一个**不可篡改的链式结构** —— 区块链
- 一旦区块被添加，其内部数据几乎无法更改，因为更改一个区块将破坏整个后续链条的哈希

4️⃣ 全网共识

- 所有节点都验证新区块是否合法（是否遵循规则、是否有双重支付等）
- 一致接受后，这个区块就被**永久记录**

### 比特币

所以比特币到底是什么，是一串哈希吗？可以理解为一个私钥，谁拥有比特币，将拥有“私钥控制某个地址”的能力，以此来证明拥有比特币

虽然比特币不是“哈希值”，但哈希算法在整个系统里大量使用，关键位置包括

| 用途       | 内容                                       | 哈希算法                 |
| ---------- | ------------------------------------------ | ------------------------ |
| 区块链结构 | 每个区块有一个哈希值，指向上一个区块       | SHA-256                  |
| 挖矿过程   | 通过不断尝试不同 nonce，找出符合难度的哈希 | SHA-256 x2               |
| 地址生成   | 比特币地址是从公钥哈希计算出来的           | RIPEMD-160（SHA-256 pk） |
| 交易 ID    | 每笔交易也有一个唯一的哈希值（txid）       | SHA-256 x2               |

可以发现全是哈希，没有所谓的加密

当拥有 1 个比特币，其实

- 你有一个私钥，对应一个地址
- 区块链账本里记录了一个或多个“未花费的输出”，指向这个地址，总金额为 1 BTC
- 当你转账时，系统检查这些 UTXO，再生成新的交易，把这些比特币“花掉”

### 双重支付

“双重支付”（Double Spending）是区块链和加密货币中最关键、也最需要防范的问题之一，它指的是：同一笔加密货币被恶意地用于多次支付，类似于**一笔钱花两次**

双重支付在比特币中的形式，假设你有 1 BTC，试图这样操作

- 把这 1 BTC 支付给商家 A
- 同时将另一笔交易广播出去，把同样的 1 BTC 支付给你的另一个地址 B
- 如果你能让“支付给 B 的交易”被矿工先打包进区块链中，那么你就“收回”了那笔钱，A 就被骗了

这就叫“双花”

比特币用以下机制来防御双花攻击

| 防御机制            | 说明                                                       |
| ------------------- | ---------------------------------------------------------- |
| ✅ 区块链结构        | 所有交易都要被打包进**单一主链（最长合法链）**，且不可更改 |
| ⛏️ 工作量证明（PoW） | 想“抢跑”插入伪造交易，需要极高算力才能制造“更长链”         |
| ⏱️ 等待多个确认      | 商家会等**6个区块确认**才认为交易不可逆                    |
| 🌐 去中心化          | 网络中成千上万节点共同验证、同步，攻击难度非常高           |

为什么双重支付难以实现？

- 要双花成功，你得**控制超过全网一半的算力**（所谓 51% 攻击）
- 即使你广播了两笔冲突交易，矿工只会打包其中**一笔**
- 其他那一笔会被网络判定为“双花交易”，直接丢弃

### 减半机制

比特币的“减半机制”是其最重要的货币发行机制之一，它是比特币**通缩模型**的核心

- 比特币减半机制是指：每当网络挖出 210000 个区块（大约每 4 年），挖矿所得的比特币奖励就会减少一半，直到总发行量接近 2100 万个比特币为止

🎯 为什么要减半？

控制总量

- 比特币的最大供应量为 2100万枚
- 如果不减半，发行会无限制增发
- 减半机制让发行量逐渐趋近于 2100 万

模拟黄金的稀缺性

- 像黄金一样，越挖越少，越来越难得
- 形成“数字黄金”的价值逻辑

抑制通货膨胀

- 减少供应速度，保证稀缺
- 吸引长期投资者，形成稳定预期

减半的经济效应

| 影响因素         | 说明                                             |
| ---------------- | ------------------------------------------------ |
| 🎯 矿工收入减少   | 如果币价不涨，矿工收益会缩水一半                 |
| 🚀 币价有上涨预期 | 因为供应减少，而需求可能稳定甚至上升             |
| 🧠 市场投机波动   | 减半前后往往伴随价格剧烈波动                     |
| 💡 挖矿难度调整   | 有些矿工退出后，全网难度会自动调整以维持出块速度 |

这其实是一个经济学问题，而并非密码学范畴，**减半事件是写死在比特币代码里的（Bitcoin Core），无法人为更改**

比特币减半机制是比特币每4年减产一半的系统规则，旨在模拟稀缺性、控制总量、增强长期价值，它是比特币“通缩”特性和“数字黄金”地位的根本来源

## 简单的矿工

SimpleMiner：其实就是一个 SHA-256 哈希，什么加密也没有

```java
public class SimpleMiner {

    // 将任意字符串进行 SHA-256 哈希
    public String sha256(String input) throws Exception {
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] hashBytes = digest.digest(input.getBytes(StandardCharsets.UTF_8));

        // 将字节数组转换为十六进制字符串
        StringBuilder hexString = new StringBuilder();
        for (byte b : hashBytes) {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) hexString.append('0');
            hexString.append(hex);
        }
        return hexString.toString();
    }

    public Map<String, Object> mine(String blockData, int difficulty){

        Map<String, Object> data = new HashMap<>();

        int nonce = 0;
        String hash;

        long startTime = System.currentTimeMillis();
        // 要求哈希值的前缀有 difficulty 个 0，才满足要求
        String targetPrefix = "0".repeat(difficulty);

        while (true) {
            // blockData 是假设的区块内容
            String input = blockData + nonce;
            try {
                hash = sha256(input);
            } catch (Exception e) {
                data.put("Error", e.toString());
                return data;
            }
            if (hash.startsWith(targetPrefix)) {
                System.out.println("找到符合条件的 nonce: " + nonce);
                System.out.println("对应哈希值: " + hash);
                data.put("nonce", nonce);
                data.put("hash", hash);
                break;
            }
            nonce++;
        }

        long endTime = System.currentTimeMillis();
        System.out.println("耗时: " + (endTime - startTime) + " ms");

        data.put("time_cost", endTime-startTime);

        return data;
    }

    public static void main(String[] args) throws Exception {
        SimpleMiner miner = new SimpleMiner();
        Map<String, Object> data = miner.mine("Alice trade 10 btc to Bob", 5);
        System.out.println(data);
    }
}
```

输入`{"Alice trade 10 btc to Bob", 5}`，输出

```
找到符合条件的 nonce: 1155772
对应哈希值: 00000a65e3e876194ca42b6663680bdd12dd6c0046b528e0cd4f1f19cb32d5d0
耗时: 1468 ms
```

