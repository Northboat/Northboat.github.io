---
title: 隐藏矢量加密和 Gray 编码优化
date: 2025-6-1
permalink: /pages/c4df29/
author: 
  name: Arkrypto
  link: https://github.com/Arkrypto
---

[Supporting secure dynamic alert zones using searchable encryption and graph embedding | The VLDB Journal](https://link.springer.com/article/10.1007/s00778-023-00803-2)

这篇论文于 2023 年 6 月发表在 VLDB Journal，该论文提出了一种支持动态告警区域（Dynamic Alert Zones）的加密位置提醒系统，结合了隐藏向量加密（HVE）和图嵌入优化技术，有效提升了加密空间匹配查询的性能

## 概述

### 安全警告区域

> Secure Alert Zones

位置数据在为移动用户提供个性化服务方面发挥着关键作用。无论是查找附近的兴趣点（POI）、获取基于位置的个性化推荐，还是与附近的朋友建立联系，位置数据极大地丰富了用户与服务之间的交互方式。然而，当前的大多数服务提供商通常会收集并存储用户的位置信息，甚至将其共享给第三方，从而严重威胁用户的隐私安全。事实上，运动轨迹数据可能泄露诸如健康状况、政治倾向或生活方式等敏感信息，因此，在保护用户隐私的前提下，支持基于位置的安全互动变得尤为重要

本文关注的核心问题是安全警报区域（Secure Alert Zones）的构建，这是一种典型的基于位置的隐私保护服务机制。在该机制中，用户通过对自身位置进行加密后上传至服务器，一旦某区域发生“敏感事件”，系统即触发告警并通知相关用户。该模型与“接触追踪”系统密切相关，在新冠疫情（COVID-19）等大规模公共卫生事件中已被证实具有显著实效。此外，安全警报区域还广泛适用于其他场景，如公共安全通知（如歹徒出没）、灾难预警，甚至商业营销（如通知用户附近的促销活动）

可搜索加密（Searchable Encryption, SE）为实现此类系统提供了关键的加密支持。通过将位置数据以特殊方式加密后上传，服务端可在密文上直接执行匹配查询（谓词判断），而无需解密数据内容，从而实现对用户隐私的保护。然而，传统的SE技术主要针对关键词匹配或数值范围查询，并非专为地理空间查询设计。因此，必须通过某种“空间到属性”的数据映射步骤，将地理位置转化为SE支持的查询形式。由于这种转换，系统性能往往面临较大的计算开销

一些系统尝试使用对称可搜索加密（SSE）方案，其中一个可信机构预先知道所有转换密钥，并在用户数据上传前完成加密。然而，这种方案虽然性能优越，但由于用户必须将明文位置暴露给可信实体，依然存在隐私泄露的风险。因此，从隐私保护的角度来看，更理想的方式应是采用一种非对称结构的可搜索加密机制（如 Hidden Vector Encryption），既能保护用户位置隐私，又具备良好的可扩展性和系统性能

此外，本文进一步考虑到现实中警告区域往往具有动态演化特性，例如：COVID-19 感染者的活动轨迹、危险气体扩散路径或突发公共事件等，其覆盖范围随时间不断变化。为此，作者引入马尔可夫模型对警告区域的演化过程建模，通过状态转移矩阵结合 Monte Carlo 采样方法，提出了可支持动态区域变化的空间编码优化机制，从而使整个系统更加贴合现实需求

### 隐藏矢量加密

> 可搜索加密（Searchable Encryption）技术的一种，隐藏向量加密 HVE（Hidden vector encryption）

HVE 是一种支持带通配符属性查询的加密技术，适合实现密文上的子集匹配、范围匹配等操作。HVE 使用公开密钥对用户位置等属性进行加密，服务端可使用由可信方生成的 Token 在不解密密文的前提下执行匹配判断。其查询复杂度依赖于 Token 中非通配符（非星号）位的数量，每个位都对应一次昂贵的双线性对计算

以 ECC 为例，一个简单的 HVE 如下：系统由三方组成（用户、可信机构（TA）和服务器），用户使用 HVE 公钥加密位置并上传，TA 指定告警区域并生成对应 Token，服务器使用 Token 匹配用户位置密文以判断是否触发告警，同时不泄露用户实际位置，假设有用户属性向量 Index 和搜索模式 Token，长度 l 均为 3
$$
I=[1,0,1]\quad T=[1,*,1]
$$
1️⃣ TA 密钥初始化

`u,h,w`均为数组，分别对应矢量的每一位属性，例如第一位属性对应密钥向量 u
$$
g\in G\quad a\in Z_p\quad u_i,h_i,w_i\in G[0\leq i<l]
$$
系统所用公钥为
$$
U_i=u_i\quad H_i=h_i\quad W_i=w_i
$$
2️⃣ 加密

TA 执行对用户 I 的消息 M 进行以下加密（这里的 M 实际上是明文消息经过哈希的结果）
$$
M\in GT\rightarrow C=(C_0,C_1,C_2,C_3)\quad
$$
其中 C0 和 C1 是单个元素，s 是随机选取的随机数
$$
C_0=M\cdot e(g,g)^{s\cdot a}\quad C_1=g^s\quad s\in Z_p
$$
 C2 和 C3 是矢量
$$
C_{2,i}=(U_i^{I_i}\cdot H_i)^s\quad C_{3,i}=W_i^s\quad 0\leq i<l
$$
3️⃣ Token 构造

对于查询`T={1,*,1}`而言，有其非通配符集合
$$
J=\{i|T_i\neq *\}
$$
其 Token 构造在非通配符集合上进行，使用私钥加密
$$
TK=(T,K_0,K_1,K_2)
$$
其中 K0 是单个元素，对于**每个**非通配符，都选取随机数`r1, r2`进行构造，也就是这样的`r1, r2`各有 l 个
$$
K_0 = g^a\cdot \Pi_{i\in J}[(u_i^{T_i}\cdot h_i)^{r_{1,i}}\cdot w_i^{r_{2,i}}]
$$
K1 和 K2 都是矢量，计算较为简单
$$
K_{1,i}=g^{r_{1,i}}\quad K_{2,i}=g^{r_{2,i}}\quad i\in J
$$
4️⃣ 查询匹配

已知密文
$$
C=(C_0,C_1,{C_{2,i}},{C_{3,i}})
$$
已知查询
$$
TK=(T,K_0,{K_{1,i}},{K_{2,i}})
$$
根据非通配符集合 J，计算
$$
M'=\frac{C_0}{e(C_1,K_0)/\Pi_{i\in J}[e(C_{2,i},K_{1,i})⋅e(C_{3,i},K_{2,i})]}
$$
其中，分子
$$
C_0=M\cdot e(g,g)^{a\cdot s}
$$
分母的第一项
$$
e(C_1,K_0)=e(g^s,K_0)=e(g,K_0)^s
$$
因为
$$
K_0 = g^a\cdot \Pi_{i\in J}[(u_i^{T_i}\cdot h_i)^{r_{1,i}}\cdot w_i^{r_{2,i}}]
$$
所以
$$
e(g,K_0)^s=e(g,g)^{a\cdot s}\cdot \Pi_{i\in J}[e(g,u_i^{T_i}\cdot h_i)^{s\cdot r_{1,i}}\cdot e(g,w_i)^{s\cdot r_{2,i}}]
$$
分母的第二项，其中有
$$
e(C_{2,i}, K_{1,i})=e((U_i^{I_i}\cdot H_i)^s, g^{r_{1,i}})=e(U_i^{I_i}\cdot H_i,g)^{s\cdot r_{1,i}}
$$
同理有
$$
e(C_{3,i},K_{2,i})=e(W_i,g)^{s\cdot r_{2,i}}
$$
所以一累乘，就等于
$$
\Pi_{i\in J}[e(U_i^{I_i}\cdot H_i,g)^{s\cdot r_{1,i}}\cdot e(W_i,g)^{s\cdot r_{2,i}}]
$$
当 I 和 T 完全一样时，分母中第一项和第二项的累乘项将完全一致，于是消去，最终匹配式将得到 M = M'，匹配成功；否则 M ≠ M'，匹配失败

### Gray 编码

Gray 编码（Gray Code），又称为反射二进制码（Reflected Binary Code, RGC），是一种相邻两个编码之间仅有一个比特位不同的二进制序列

在普通的二进制编码中，相邻两个数可能有多个比特不同，比如

```scss
0111 (7)
1000 (8)
```

Hamming 距离是 4（全部位都变了），但在很多系统（如模拟转数字、电路设计、密文匹配）中希望相邻编号变动尽量小，以避免

- 跳变误差（glitch）
- 编码抖动
- 配对计算冗余

于是就出现了 Gray 编码，Gray 编码是一种重新排列的二进制序列，使得任意两个相邻编码的 Hamming 距离为 1，例如 3 位 Gray 编码和普通二进制的对比

| 十进制 | 二进制 | Gray 编码 |
| ------ | ------ | --------- |
| 0      | 000    | 000       |
| 1      | 001    | 001       |
| 2      | 010    | 011       |
| 3      | 011    | 010       |
| 4      | 100    | 110       |
| 5      | 101    | 111       |
| 6      | 110    | 101       |
| 7      | 111    | 100       |

可以看到，Gray 编码列中相邻两个数只有一个比特不同

在本论文中，Gray 编码用于将空间中的网格（cell）编号映射为 HVE 支持的属性向量（如 6 位二进制），使用 Gray 编码而不是普通二进制，可以确保

- 邻近的空间单元，其编码在 Hamming 空间中也尽可能接近
- 从而在生成 HVE 查询 Token 时减少非星号位，降低加密搜索开销
- 配合图嵌入优化进一步压缩编码距离

 Gray 编码空间

- 对于 k-bit 编码，共有 2^k 个 Gray 编码点。
- 每个编码是一个二进制向量，如：`0000`, `0001`, `0011`, ..., `1111`
- 这些编码在 Hamming 空间中可视为一个 k 维超立方体

我们把这些编码称为 Gray 编码“点”或“位置”，每个编码可以被分配给一个 cell 空间

### 图嵌入优化技术

> Graph Embedding

为降低 HVE 查询开销，论文采用图嵌入技术对空间位置编码进行优化。作者将空间划分为网格（cell），并将其嵌入到高维 k-cube 中，使用 Binary-Reflected Gray（BRG）路径生成规则实现 Token 与空间位置之间的一一对应关系，同时利用 Gray 编码和图匹配优化使得落入同一告警区域的多个位置在编码上更加相似，从而减少 Token 中的非星号位数量，进而降低 HVE 操作代价

举一个图嵌入优化空间位置编码的简明例子：假设我们有一个城市被划分成 9 个小网格区域，编号如下

```less
Grid (cell layout):

[0] [1] [2]
[3] [4] [5]
[6] [7] [8]
```

假设有一个告警区域，包含 cell 编号为

```css
Alert Zone: {1, 2, 4, 5}
```

原始做法用 Gray 编码：对 9 个 cell 直接编号，然后进行 4 位二进制编码（因为 2^4 = 16 > 9）

| Cell | Binary | Gray Code |
| ---- | ------ | --------- |
| 0    | 0000   | 0000      |
| 1    | 0001   | 0001      |
| 2    | 0010   | 0011      |
| 3    | 0011   | 0010      |
| 4    | 0100   | 0110      |
| 5    | 0101   | 0111      |
| 6    | 0110   | 0101      |
| 7    | 0111   | 0100      |
| 8    | 1000   | 1100      |

然后，把这些 Gray 编码用于 HVE 中，告警区域的 Token 会有如下匹配要求：比如`cell 1`是`0001`，`cell 5`是`0111`，二者 Hamming 为 2 → Token 中至少两个非“星号”位

图嵌入优化的目的：让告警区域内的 cell 的编码在 Hamming 空间中尽量靠近 → 减少 Token 中的非“星号”位数量 → 减少 HVE 的配对开销

图嵌入优化（GO / MSGO 思想）：论文中通过构造 Gray 编码路径，**将这些 cell 在 k-cube 图中映射到 Hamming 距离接近的位置**

一个重新编码的例子

| Cell | Optimized Gray Code |
| ---- | ------------------- |
| 1    | 0000                |
| 2    | 0001                |
| 4    | 0011                |
| 5    | 0010                |
| 0    | 0110                |
| 3    | 0111                |
| 6    | 0101                |
| 7    | 0100                |
| 8    | 1100                |

这样，告警区域中所有点`{1,2,3,5}`之间的 Hamming 距离最多为 2，用于搜索的 Token 只需要最多 2 个非星号位

## 三种启发式优化算法

文章提出三种启发式优化算法用于优化 Gray 编码，以期最大程度降低警告区域编码之间的汉明距离

1. Gray Optimizer（GO）：以概率最高位置为种子，按 Hamming 距离逐层匹配最大概率 BRG 路径，适用于小规模网格
2. Multiple Seed GO（MSGO）：将整个网格划分为多个小簇，每个簇独立执行 GO，适合中等粒度网格，支持指定优化深度
3. Scaled GO（SGO）：所有位置均作为种子，仅执行深度为 1 的 GO，计算复杂度最低，适合大规模场景

### Gray Optimizer

GO（Gray Optimizer）算法是文章中提出的一种图嵌入启发式优化方法，其目标是：将一个概率分布下的重要网格单元（grid cell）嵌入到 Gray 编码空间中，使它们的编码尽可能相似，从而减少 HVE 查询中 Token 的非星号位数量，降低配对计算成本

算法输入

- 一个 cell 概率向量（如告警区域内 cell 出现的概率），用作“重要性”指标
- 一个 Gray 编码空间（如 k-bit，最多 2^k 个点）

算法输出：一种 cell → Gray 编码的映射，使得高概率 cell 映射到彼此靠近的 Gray 编码

GO 算法步骤

1️⃣ 步骤 1：选择种子点

- 从所有 cell 中选出概率最高的一个，作为起始点（seed）
- 将其分配给 Hamming 空间中的 Gray 编码路径的起点（如`000000`）

2️⃣ 步骤 2：按照 Gray 编码路径展开

- 在 Gray 编码空间中，从起点出发构建一条 Gray 路径（每次只变一位）
- 对每个新位置，选择当前剩余 cell 中概率最大的那个进行映射（贪心策略）
- 每次只访问未被占用的 Gray 编码点

3️⃣ 步骤 3：继续直到映射完所有 cell

- 直到所有目标 cell 都被分配到一个 Gray 编码位置为止

举个例子，假设你有以下 4 个 cell，其概率分别为

```yaml
Cell 0: 0.4
Cell 1: 0.3
Cell 2: 0.2
Cell 3: 0.1
```

可用的 2-bit Gray 编码为：`00`, `01`, `11`, `10`

GO 会按概率顺序分配路径

```css
Cell 0 → 00
Cell 1 → 01
Cell 2 → 11
Cell 3 → 10
```

你可以看到，它们形成了一条 Gray 路径（相邻两个码只相差 1 位），这样一来：HVE Token 中，只需 1~2 个非星号位即可同时匹配多个 cell

局限性

- 只能处理数量较小的 cell 子集，因为是线性遍历 Gray 路径，适合精确嵌入
- 当 cell 数量大时，后续论文提出了 MSGO / SGO 作为 GO 的扩展优化

### Multiple Seed GO

GO（Gray Optimizer）适用于“小规模网格优化”，其核心思想是从一个高概率的 seed 出发，沿 Gray 编码路径逐个分配编码。但如果 cell 数量变大（例如 100+ 个 cell）

- Gray 路径变长、编码冲突概率上升
- 单路径嵌入带来的局部最优不再有效
- 算法效率明显下降

因此作者提出 MSGO 和 SGO 两种可扩展的优化策略

MSGO：将大网格区域划分为多个小簇（cluster），每个簇独立使用 GO 进行优化，再合并编码结果

输入参数

- `cell_probabilities`：所有 cell 的概率值
- `depth`：每个簇中最多可优化的深度（控制簇大小）

算法步骤

1. **按概率排序**所有 cell
2. 每`depth`个 cell 分为一组 ⇒ 得到多个小簇
3. 对每个簇按照 GO 的方式单独执行一次 Gray 编码路径分配
4. 合并所有簇的编码映射，形成完整网格的 Gray 编码表

特点

| 指标       | 表现                              |
| ---------- | --------------------------------- |
| 编码效率   | 优于 GO（在中等规模下）           |
| 灵活性     | 可以控制 depth 以适应不同场景     |
| 匹配性能   | 相较未优化显著下降 Token 指定位数 |
| 计算复杂度 | 中等，复杂度 O(n)，可并行         |

### Scaled GO

极大规模网格嵌入优化场景下（如 1000+ 个 cell），即使 MSGO 分组仍然计算复杂，SGO 使用更轻量的策略

算法步骤

1. 每个 cell 都作为一个“种子”，但不再从某个起点展开 Gray 路径
2. 每个 cell 仅分配 Gray 编码空间中**最接近未使用**的编码点
3. 编码选择**仅考虑其概率邻近性，不保证 Gray 路径结构**
4. 整体采用广度优先 + 低深度匹配的方式，提升速度

什么叫不保证 Gray 路径结构？

- 在 GO 算法中，我们会构建一条完整 Gray 结构，即每两次分配的 Gray 编码一定是相邻的，且被分配的区域一定是概率从大到小排序好的
- 但是在 SGO 中，他并不保证每两次分配的 Gray 编码相邻，比如`0000`和`0001`和`0011`是三个相邻的 Gray 编码，对于基于权重排好序的三个区域`cell 1(4), cell 2(3), cell 3(1)`
  - 如果是 GO 算法，那么就会依次分配`0000`和`0001`和`0011`，相邻的汉明距离始终为 1
  - 如果是 SGO，则不满足这样的要求，他会去找“最近的编码”有可能分配为`0011, 0000, 0001`，他并不考虑 Gray 编码的路径

Gray 路径具有结构性嵌入，而 SGO 是一种“稀疏散列式”的编码分配

举个例子，3 位的 Gray 编码空间共 8 个点

```css
['000', '001', '011', '010', '110', '111', '101', '100']
```

假设你有 4 个告警区域 cell，要做映射

- Step 1：第一个 cell → 概率最高，直接分配 `000`
- Step 2
  1. 第二个 cell，要从剩下的 7 个 Gray 编码中选
  2. 它去“看”哪一个 Gray 编码与已使用的 `000` Hamming 距离最近
  3. 比如 `001`, `010`, `100` 都只差 1 位 ⇒ 任意选一个最近的“空位”
- Step 3
  1. 第三个 cell → 计算它与前两个 cell 的 Gray 编码的平均 Hamming 距离
  2. 在剩下的空位中找那个“平均距离最小”的点 ⇒ 分配

### GO VS. SGO

为什么 SGO 实际上“更轻量”“更可扩展”？

1️⃣ GO 的核心是构造 Gray 路径（依赖图结构）

GO 要构造一个**Gray 路径图**，路径上的每一步都需要

- 找当前 Gray 编码的**邻接编码**（Hamming 距离 = 1）
- 从中选概率最高的 cell 分配 ⇒ 需要记录已分配状态 + 路径维护 + 动态更新候选集

即使看起来是 O(n)，但内部

- 每一步都要查找邻接点（最多 k 个）
- 查找候选 cell 概率最大的（优先队列）
- 保证路径不重复、不能跳跃 ⇒ **是图遍历 +优先队列 + 贪心搜索的组合**

🔺 不可并行、维护路径结构开销大

2️⃣ SGO 是“静态编码空间 + 局部贪心”

SGO 中，每个 cell

- 不需要考虑路径
- 只需要从剩下的 Gray 编码中找一个“最接近”的未使用编码

虽然也要做查找，但

- 不需要维护 Gray 路径图
- 可使用预先计算好的编码之间的 Hamming 距离矩阵
- 可以用简单排序 + 标记数组来分配
- 甚至可以并行地分配多个 cell

✅ 所以实际复杂度 ≈ O(n)，**但更可并行、更易实现、更缓存友好**

## 代码复现

本次复现选取了 HVE 与 GO 算法部分进行实现

### Gray 路径构建

> 对 GO（Gray Optimizer）算法的复现，基于 Gray 编码路径的贪心式映射策略，能将高概率告警区域压缩进 Hamming 空间中的紧凑区域，减少 HVE Token 指定位数，从而降低查询成本

具体步骤

- 先生成一组空间网格 ID（如编号 0～31），每个网格用 Gray 编码表示
- 模拟一个告警区域（如 8 个 grid cell）
- 统计这些 cell 的 Gray 编码之间的平均 Hamming 距离
- 使用优化策略（例如 BFS 排列、排序靠近）对编号进行调整，使得区域内部编码更接近

算法输入：区域和其对应权重集合

```java
Map<String, Double> cells;
```

算法输出：区域和其对应的 Gray 编码

```java
Map<String, String> gray;
```

算法的关键是构建完整的 Gray 路径，而后按照顺序分配给当前权重最高的区域即可，那么如何构建呢

Gray 路径是指：一条在 Gray 编码空间中，每两个相邻编码 Hamming 距离 = 1 的路径，例如在 3 位 Gray 编码空间中，完整 Gray 路径为

```
000 → 001 → 011 → 010 → 110 → 111 → 101 → 100
```

它是一条在 3 维超立方体上的 **Hamiltonian Path**

我们使用 **Binary Reflected Gray Code（BRGC）** 构造规则，它的思路是：递归生成 n 位 Gray 编码序列
$$
G(n) =
\begin{cases}
0 + G(n-1)\\
1 + reverse(G(n-1))\\
\empty\quad n=0
\end{cases}
$$
注意这里的 reverse 是把集合倒过来遍历的意思，并非对字符翻转

比如
$$
G(1) = 
\begin{cases}
0+G(0)=0\\
1+reverse(G(0))=1
\end{cases}
\Rightarrow\{0,1\}
$$
则有
$$
G(2)=
\begin{cases}
0+G(1)=00/01\\
1+reverse(G1)=11/10
\end{cases}
\Rightarrow\{00,01,11,10\}
$$
那么
$$
G(3)=
\begin{cases}
0+G(2)=000/001/011/010\\
1+reverse(G2)=110,111,101,100
\end{cases}
\Rightarrow\{000,001,011,010,110,111,101,100\}
$$
以此类推

Gray 路径构造

```java
public List<String> buildGrayPath(int l) {
    if (l == 0) return new ArrayList<>(List.of(""));
    List<String> prev = buildGrayPath(l-1);
    List<String> path = new ArrayList<>();

    // 正序添加，前缀 0
    for (String code : prev) {
        path.add("0" + code);
    }
    // 反序添加，前缀 1
    for (int i = prev.size()-1; i >= 0; i--) {
        path.add("1" + prev.get(i));
    }
    return path;
}
```

### 区域编码

GO 贪心实现

```java
public Map<String, String> grayOptimizer(Map<String, Double> cells, int l){
    // 构建长度为 l 的 Gray 编码路径
    if(cells.size() > Math.pow(2, l)){
        System.out.println("Cells too Much, Can't Encode");
        return null;
    }
    List<String> codes = buildGrayPath(l);
    System.out.println(codes);

    // 构建大顶堆，对 cells 按照权重从大到小排序
    PriorityQueue<String> sortedCells = new PriorityQueue<>((a, b) -> {
        if(cells.get(b) - cells.get(a) < 0){
            return -1;
        } else if(cells.get(b) - cells.get(a) == 0){
            return 0;
        } else {
            return 1;
        }
    });
    for(String cell: cells.keySet()){
        sortedCells.offer(cell);
    }

    // 分配 Gray 编码
    Map<String, String> grayCode = new HashMap<>();
    int i = 0;
    while(!sortedCells.isEmpty()){
        String cell = sortedCells.poll();
        String code = codes.get(i++);
        grayCode.put(cell, code);
    }
    return grayCode;
}
```

###  HVE 实现

> 采用 JPBC 编写，实现一个简化版本的 HVE 加密 + Token 生成 + 匹配功能，用于支持布尔向量上的匹配测试

具体功能

| 步骤       | 内容                           |
| ---------- | ------------------------------ |
| 参数生成   | 生成随机群元素，构造密钥结构   |
| 加密       | 输入属性向量 I，输出密文结构   |
| 生成 Token | 输入查询向量 T，构造 Token     |
| 匹配判断   | 输入密文与 Token，判断是否匹配 |

这里的 I/T 矢量实际上就是 Gray 编码，只不过要字符上的 1/0 转化为 Zp 群上的 One/Zero 来参与计算，而加密过程中的 M 可以是用户携带的真实消息，例如 userID、标识、通知触发信息等

初始化

```java
public class HVE extends CipherSystem {
    
    private final Element M;
    private final int l;
    public HVE(Field G1, Field GT, Field Zr, Pairing BP, int n, int l) {
        super(G1, GT, Zr, BP, n);
        this.l = l;
        M = HashUtil.hashStr2GT(this.getZr(), randomGT(), "test", this.getN());
    }
    
    Element g, a;
    @Override
    public void setup() {
        g = randomG();
        a = randomZ();
    }


    Element[] u, h, w, U, H, W;
    @Override
    public void keygen() {
        u = new Element[l];
        h = new Element[l];
        w = new Element[l];
        U = new Element[l];
        H = new Element[l];
        W = new Element[l];
        for(int i = 0; i < l; i++){
            Element t = randomG();
            u[i] = t; U[i] = t;
            t = randomG();
            h[i] = t; H[i] = t;
            t = randomG();
            w[i] = t; W[i] = t;
        }
    }
}
```

加密

```java
Element C0, C1;
Element[] C2, C3;
@Override
public void enc(String w) {
    Element s = randomZ();
    C0 = M.mul(pairing(g, g).powZn(a.mul(s))).getImmutable();
    C1 = g.powZn(s).getImmutable();

    C2 = new Element[l];
    C3 = new Element[l];
    for(int i = 0; i < l; i++){
        Element I = w.charAt(i) == '1' ? getI("1") : getI("0");
        C2[i] = U[i].powZn(I).mul(H[i]).powZn(s).getImmutable();
        C3[i] = W[i].powZn(s).getImmutable();
    }
}
```

陷门计算

```java
String T;
Element K0;
Element[] K1, K2;
@Override
public void trap(String q) {
    T = q;
    K1 = new Element[l];
    K2 = new Element[l];

    Element c = this.getG().newOneElement();
    for(int i = 0; i < l; i++){
        if(q.charAt(i) != '*'){
            Element T = q.charAt(i) == '1' ? getI("1") : getI("0");
            Element r1 = randomZ(), r2 = randomZ();
            K1[i] = g.powZn(r1).getImmutable();
            K2[i] = g.powZn(r2).getImmutable();
            c.mul(u[i].powZn(T).mul(h[i]).powZn(r1).mul(w[i].powZn(r2)));
        }
    }
    c.getImmutable();
    K0 = g.powZn(a).mul(c).getImmutable();

}
```

匹配

```java
@Override
public boolean search() {
    Element part1 = pairing(C1, K0);
    Element part2 = this.getGT().newOneElement();
    for(int i = 0; i < l; i++){
        if(T.charAt(i) != '*'){
            Element part3 = pairing(C2[i], K1[i]);
            Element part4 = pairing(C3[i], K2[i]);

            part2.mul(part3.mul(part4));
        }
    }
    part2.getImmutable();

    Element M1 = C0.div(part1.div(part2)).getImmutable();

    System.out.println("HVE M: " + M);
    System.out.println("HVE M': " + M1);
    return M.isEqual(M1);
}
```

### 测试

Gray 编码，输入权重

```java
Map<String, Double> cells = new HashMap<>();
cells.put("A", 0.85);
cells.put("B", 0.15);
cells.put("C", 0.60);
cells.put("D", 0.35);
cells.put("E", 0.95);
```

当分别深度为`3, 4, 5, 6, 7`时的 Gray 编码

```sh
Cell A → 001
Cell B → 110
Cell C → 011
Cell D → 010
Cell E → 000

Cell A → 0001
Cell B → 0110
Cell C → 0011
Cell D → 0010
Cell E → 0000

Cell A → 00001
Cell B → 00110
Cell C → 00011
Cell D → 00010
Cell E → 00000

Cell A → 000001
Cell B → 000110
Cell C → 000011
Cell D → 000010
Cell E → 000000

Cell A → 0000001
Cell B → 0000110
Cell C → 0000011
Cell D → 0000010
Cell E → 0000000
```

HVE 加密测试

输入`I = {1, 0, 1}, T = {1, *, 1}` → 匹配成功

```java
C0: {x=7396270119708543985778186618799547261532143231415867966890956335550446346416110877519597975854317515739535615461217444339606813035116023043384963639127985,y=2410527565763547130980988180260070069511839913351196150171321784120180403084211090737752523111269077021515025730247312281943676565805892491012638606536691}
K0: 4402036133642751352703755153995326626935186944319804700574649550255909892611483763309719480250860393422773681400436515607599287816664284648258838838872701,4033221352264511863364393883987936857610878803138080737946503976387838071871779846950131310828155968825231538635981183133927706099016947836471336606302553,0
HVE M: {x=8166931583646481065998751188576001878217498289243201241215326888796595122069367791706077543327305749314852025344913846292797816350134949694485911504671540,y=1278676158800519029475835175658466070108029450475095045512197561131861023305484003190491839101595327852411215610616959246348578904041917714106820841300032}
HVE M': {x=8166931583646481065998751188576001878217498289243201241215326888796595122069367791706077543327305749314852025344913846292797816350134949694485911504671540,y=1278676158800519029475835175658466070108029450475095045512197561131861023305484003190491839101595327852411215610616959246348578904041917714106820841300032}
true
```

输入`I = {1, 0, 1}, T = {1, *, 0}` → 匹配失败

```java
C0: {x=7905231742878042078052264052787084462719596228129744921048468485350307877389899552033425284543907954037707941039880717161431986791304351103397014682945890,y=6765753836553197554053980616301317785282188941077501048620927687732189139660469013577384733015213937736880632327982042576161149092091566237929999952544313}
K0: 3285069086772909641071714695617507694749561507999645630525915305369335748993061646989481845076233740973882548375460666673320486057685227390450992278941805,3883481496557219945011151549304082575960377615679838580050875137166510993084654604265764961868605838035297685901917632735231461576111799590760176084234845,0
HVE M: {x=6327770586201588838797080515280727133170446361531141160814071365385656491081058678379386104282317635719308569836165044623600128098546171947836997615129664,y=7876405449751082059297082511288283654580728965857935056112390684827045132981839734196728251994461594973468807031950445163313853553451606091083631705998163}
HVE M': {x=6485675283445597533179596766542947967931764989052751909885756449851295203555250792213705985543725889339723058731105078844781647485389178632511896616396204,y=2644058816079949704674769773205684526731675165937362088783170253807076444069114301931994605332433487029250316684492267743649792759498678322930863265760029}
false
```

