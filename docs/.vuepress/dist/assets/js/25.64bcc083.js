(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{1053:function(s,t,a){s.exports=a.p+"assets/img/image-20230823014330133.64a366d4.png"},1054:function(s,t,a){s.exports=a.p+"assets/img/image-20230823020439142.98e062a7.png"},1055:function(s,t,a){s.exports=a.p+"assets/img/image-20230829205423668.cc7d0145.png"},1056:function(s,t,a){s.exports=a.p+"assets/img/image-20230829205138085.1c11bcdc.png"},1057:function(s,t,a){s.exports=a.p+"assets/img/image-20230829210735230.e0c4f8a9.png"},1058:function(s,t,a){s.exports=a.p+"assets/img/image-20230829210804597.bb4c2edc.png"},1059:function(s,t,a){s.exports=a.p+"assets/img/image-20230829211922505.ef8ca5a8.png"},1060:function(s,t,a){s.exports=a.p+"assets/img/image-20230829211948118.1424d0a7.png"},1061:function(s,t,a){s.exports=a.p+"assets/img/image-20230829212034948.4b1fc28d.png"},1062:function(s,t,a){s.exports=a.p+"assets/img/image-20230829204216994.828e1493.png"},1063:function(s,t,a){s.exports=a.p+"assets/img/image-20230829210447046.7f54c57d.png"},1064:function(s,t,a){s.exports=a.p+"assets/img/image-20230829210513661.0eab0e23.png"},1065:function(s,t,a){s.exports=a.p+"assets/img/image-20230829212142577.44f3f1e2.png"},1066:function(s,t,a){s.exports=a.p+"assets/img/image-20230829212220945.cb313246.png"},1067:function(s,t,a){s.exports=a.p+"assets/img/image-20230829212409958.6ceb2fbe.png"},1587:function(s,t,a){"use strict";a.r(t);var v=a(4),_=Object(v.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("p",[s._v("根据明文产生一个属于当前明文的特定码，用于认证内容未被修改，根据明文产生认证码，其过程就相当于将明文视作密钥，对某一初始自定义内容进行加密，这里的加密常使用 CBC 模式的 DES 算法和某些公钥算法")]),s._v(" "),t("ul",[t("li",[s._v("这和分组加密的思路是一模一样的（区块链）")])]),s._v(" "),t("p",[s._v("哈希函数实际上就是对加密算法的封装，可以同时包含多种算法（包含分组加密和公钥加密），使一个较长的输入（明文）输出一个定长的较短码")]),s._v(" "),t("h2",{attrs:{id:"消息认证码-mac"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息认证码-mac"}},[s._v("#")]),s._v(" 消息认证码 MAC")]),s._v(" "),t("h3",{attrs:{id:"cbc-模式-des-的数据认证算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cbc-模式-des-的数据认证算法"}},[s._v("#")]),s._v(" CBC 模式 DES 的数据认证算法")]),s._v(" "),t("blockquote",[t("p",[s._v("基于 CBC 模式 DES 算法")])]),s._v(" "),t("p",[s._v("消息认证码的实现和作用可以参考用于差错检测的海明码和循环冗余码，都是通过在原数据后冗余一段码用于验证，这段码和数据在传输过程中保持一个整体，若在未知密钥的情况下篡改，将破坏整段数据的完整性，从而验证失败，接收方据此得知数据出了问题")]),s._v(" "),t("p",[s._v("区别在于，循环冗余码采用二进制整除的形式验证其完整性，而消息认证码采用加密算法验证其完整性（当然，码的生成也基于加密算法，不然怎么验证）")]),s._v(" "),t("p",[s._v("消息认证算法：基于 CBC 运行模式的 DES 算法")]),s._v(" "),t("ul",[t("li",[s._v("CBC，Cipher Block Chain，密码分组链")]),s._v(" "),t("li",[s._v("DES，Data Encryption Standard，标准加密算法")])]),s._v(" "),t("p",[s._v("一毛吊样")]),s._v(" "),t("img",{attrs:{src:a(1053)}}),s._v(" "),t("p",[s._v("这里的 O 在 DES 加密中就是一个个密文分组，经过密钥 K 加密，CBC 模式的每轮密钥不变，采用将上一轮密文和当前轮明文异或再 DES 加密的形式实现扩散性，这样同一明文分组将对应不同密文组")]),s._v(" "),t("h3",{attrs:{id:"cfb-模式-des-的数据认证算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cfb-模式-des-的数据认证算法"}},[s._v("#")]),s._v(" CFB 模式 DES 的数据认证算法")]),s._v(" "),t("p",[s._v("用 CFB 模式的 DES 算法模拟以 0 为初始向量的 CBC 模式 DES 数据认证算法")]),s._v(" "),t("h2",{attrs:{id:"哈希函数和生日攻击"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#哈希函数和生日攻击"}},[s._v("#")]),s._v(" 哈希函数和生日攻击")]),s._v(" "),t("h3",{attrs:{id:"哈希函数性质"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#哈希函数性质"}},[s._v("#")]),s._v(" 哈希函数性质")]),s._v(" "),t("p",[s._v("哈希函数满足：单向性；无碰撞性")]),s._v(" "),t("img",{attrs:{src:a(1054)}}),s._v(" "),t("p",[s._v("其中性质 6 用于抵御生日攻击")]),s._v(" "),t("h3",{attrs:{id:"生日攻击"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#生日攻击"}},[s._v("#")]),s._v(" 生日攻击")]),s._v(" "),t("p",[s._v("第一类生日攻击：找到一个 y 令 h(y) 等于已知的一个哈希值 h(x)，其穷举的长度 k 至少为 n/2（n 为哈希函数所有可能的输入长度）")]),s._v(" "),t("p",[s._v("第二类生日攻击：找到一对输入 x 和 y，满足其哈希值相等，即 h(x) = h(y)，其穷举的长度 k 至少为 √n（n 为哈希函数所有可能的输入长度）")]),s._v(" "),t("h3",{attrs:{id:"常见哈希函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见哈希函数"}},[s._v("#")]),s._v(" 常见哈希函数")]),s._v(" "),t("p",[s._v("MD5 杂凑算法：缓冲器中，数据小端存储，产生认证码 128 位（4 个 32 位寄存器构成缓冲）")]),s._v(" "),t("p",[s._v("安全杂凑算法 SHA：缓冲器中，数据大端存储，产生认证码 160 位（5 个 32 位寄存器构成缓冲）")]),s._v(" "),t("p",[s._v("HMAC：使用哈希函数产生 MAC（Message Authentication Code，消息认证码）")]),s._v(" "),t("h2",{attrs:{id:"消息认证-vs-数字签名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息认证-vs-数字签名"}},[s._v("#")]),s._v(" 消息认证 VS. 数字签名")]),s._v(" "),t("h3",{attrs:{id:"消息认证的缺陷"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息认证的缺陷"}},[s._v("#")]),s._v(" 消息认证的缺陷")]),s._v(" "),t("p",[s._v("对于消息认证机制，其加密方式是发方、收方共有的，不管是用的分组密码还是公钥密码对明文进行加密产生认证码，生成方式都是共有的，也就是说，"),t("strong",[s._v("任意一个收方 B，都可以伪装成 A 向外发送消息")]),s._v("，其他的收方 C 也根据同一个加密方式处理收到的明文并认证，认为这条消息为 A 所发")]),s._v(" "),t("p",[s._v("显然，此时 C 不知道收方 B 假冒了发方 A 发送了消息")]),s._v(" "),t("p",[s._v("相互的，当 A 发出了负面消息，可以以加密方式泄露的借口将锅丢给某个收方 B 的身上或是某个不存在的收方 D 身上")]),s._v(" "),t("img",{attrs:{src:a(1055)}}),s._v(" "),t("p",[s._v("究其原因，就是这里的"),t("strong",[s._v("认证机制仅仅只依赖于加密这一过程")]),s._v("，将收到的明文"),t("strong",[s._v("单方向的加密")]),s._v("，再和与明文一起收到的认证码进行比对，完成认证")]),s._v(" "),t("p",[s._v("实际上，消息认证执行的是：发方加密，收方加密的认证方式")]),s._v(" "),t("p",[s._v("这也是为什么哈希函数被设计为单向性的原因（只涉及到加密，而不涉及解密）")]),s._v(" "),t("h3",{attrs:{id:"数字签名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数字签名"}},[s._v("#")]),s._v(" 数字签名")]),s._v(" "),t("p",[s._v("不同于消息认证，数字签名将整个明文加密，将这个加密的完整密文 E(M) 发送给收方，收方解密获取明文，你会发现这就是第二、三章的具体应用过程（包含加密和解密）")]),s._v(" "),t("p",[s._v("过程对比")]),s._v(" "),t("ul",[t("li",[s._v("数字签名：加密明文、传输密文、解密密文、比对明文")]),s._v(" "),t("li",[s._v("消息认证：加密明文、传输明文和密文、二次加密明文、比对密文")])]),s._v(" "),t("p",[s._v("注意下图中的阴影框框并不是代表整个明文信息，而是表示签名，在真正传输的时候，和消息认证码类似，也是将 E(M) 链在 M 后进行发送")]),s._v(" "),t("img",{attrs:{src:a(1056)}}),s._v(" "),t("p",[s._v("显然，数字签名执行的是：发方加密，收方解密的认证方式")]),s._v(" "),t("p",[s._v("只要解密成功，就能确认该消息由 A 所发（因为用的他的密钥），而收方 B 并不可以根据他所已知的信息假冒 A 对外发送消息，于是避免了收方假冒发方的情况")]),s._v(" "),t("p",[s._v("同时可以以"),t("strong",[s._v("仲裁方式")]),s._v("确认消息被 A 发送过，即 A 要发送给 B，私钥加密后，先发给第三方 D，D 对这条消息进行确认，加入某些信息，再传给 B，这样 A 就无法否认他发过这条消息，也无法以私钥泄露进行甩锅")]),s._v(" "),t("p",[s._v("与之对应的直接方式存在 A 甩锅的风险")]),s._v(" "),t("h2",{attrs:{id:"数字签名标准"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数字签名标准"}},[s._v("#")]),s._v(" 数字签名标准")]),s._v(" "),t("h3",{attrs:{id:"dss-方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dss-方式"}},[s._v("#")]),s._v(" DSS 方式")]),s._v(" "),t("p",[s._v("不同于 RSA 的签名，其包括密钥生成、签名、认证三个完整阶段")]),s._v(" "),t("img",{attrs:{src:a(1057)}}),s._v(" "),t("img",{attrs:{src:a(1058)}}),s._v(" "),t("p",[s._v("上述 DSS 过程中")]),s._v(" "),t("ul",[t("li",[s._v("H 为哈希函数，进行加密的对象其实是明文 M 的哈希值，这么做的原因很简单，为了缩小规模和规范化加密输入")]),s._v(" "),t("li",[s._v("PK(G) 是发方和收方共有一个单钥，SK(A) 是发方的私钥，PK(A) 是发方的公钥，k 为加密的随机数，共同加密 H(M)，即 Sig 过程")]),s._v(" "),t("li",[s._v("s 和 r 分别为单钥 PK(G) 的密文和公钥 SK(A)/PK(A) 的密文，共同参与解密")]),s._v(" "),t("li",[s._v("最后，收方根据收到的明文产生哈希值 H(M)，和对签名（密文）的解密内容进行比对，确认签名的正确性")])]),s._v(" "),t("h3",{attrs:{id:"数字签名算法-dsa"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数字签名算法-dsa"}},[s._v("#")]),s._v(" 数字签名算法 DSA")]),s._v(" "),t("p",[s._v("在 DSS 中，使用的公钥算法是 DSA 算法，基于 ElGamal 和 Schnorr 两个签名方案设计，其安全性基于求离散对数的困难性")]),s._v(" "),t("img",{attrs:{src:a(1059)}}),s._v(" "),t("img",{attrs:{src:a(1060)}}),s._v(" "),t("p",[s._v("为了更好理解，贴一个程序框图")]),s._v(" "),t("img",{attrs:{src:a(1061)}}),s._v(" "),t("h2",{attrs:{id:"常见签名体制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见签名体制"}},[s._v("#")]),s._v(" 常见签名体制")]),s._v(" "),t("h3",{attrs:{id:"rsa-签名体制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rsa-签名体制"}},[s._v("#")]),s._v(" RSA 签名体制")]),s._v(" "),t("img",{attrs:{src:a(1062)}}),s._v(" "),t("img",{attrs:{src:a(1063)}}),s._v(" "),t("img",{attrs:{src:a(1064)}}),s._v(" "),t("h3",{attrs:{id:"elgamal-签名体制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#elgamal-签名体制"}},[s._v("#")]),s._v(" ElGamal 签名体制")]),s._v(" "),t("blockquote",[t("p",[s._v("小重点，基于离散对数")])]),s._v(" "),t("p",[s._v("算法描述及一个栗子")]),s._v(" "),t("img",{attrs:{src:a(1065)}}),s._v(" "),t("img",{attrs:{src:a(1066)}}),s._v(" "),t("p",[s._v("还真是")]),s._v(" "),t("h3",{attrs:{id:"schnorr-签名体制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#schnorr-签名体制"}},[s._v("#")]),s._v(" Schnorr 签名体制")]),s._v(" "),t("p",[s._v("看一看就行，算法描述如下")]),s._v(" "),t("img",{attrs:{src:a(1067)}}),s._v(" "),t("h3",{attrs:{id:"安全密码协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安全密码协议"}},[s._v("#")]),s._v(" 安全密码协议")]),s._v(" "),t("ul",[t("li",[s._v("基本协议")]),s._v(" "),t("li",[s._v("零知识证明")]),s._v(" "),t("li",[s._v("安全多方计算协议")])])])}),[],!1,null,null,null);t.default=_.exports}}]);