(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{1498:function(v,_,s){"use strict";s.r(_);var t=s(4),a=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("参考书目")]),v._v(" "),_("ul",[_("li",[v._v("《数据库系统概念》（译，原书第7版），机械工业出版社，杨冬青，李红燕，张金波等译")]),v._v(" "),_("li",[v._v("《分布式数据库系统原理》（译，原书第3版），清华大学出版社，周立柱等译")])]),v._v(" "),_("h2",{attrs:{id:"数据库内核概述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库内核概述"}},[v._v("#")]),v._v(" 数据库内核概述")]),v._v(" "),_("h3",{attrs:{id:"关系型数据库"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关系型数据库"}},[v._v("#")]),v._v(" 关系型数据库")]),v._v(" "),_("p",[v._v("数据管理技术三个阶段")]),v._v(" "),_("ul",[_("li",[v._v("人工管理")]),v._v(" "),_("li",[v._v("文件系统")]),v._v(" "),_("li",[v._v("数据库系统")])]),v._v(" "),_("p",[v._v("数据库系统（DBMS）")]),v._v(" "),_("ul",[_("li",[v._v("数据库 DB")]),v._v(" "),_("li",[v._v("数据库管理系统 DBMS：管理数据库软件")]),v._v(" "),_("li",[v._v("数据库系统 DBS：引入数据库后的计算机系统")])]),v._v(" "),_("p",[v._v("DBMS 主要功能：1️⃣ 数据定义功能 2️⃣ 数据组织、存储和管理 3️⃣ 数据操纵 4️⃣ 数据控制 5️⃣ 数据库的建立和维护")]),v._v(" "),_("p",[v._v("DBMS 主要构成")]),v._v(" "),_("img",{attrs:{src:s(553)}}),v._v(" "),_("p",[v._v("关系型数据库数据模型：是严格定义的一组概念的集合。精确描述了系统的静态特性、动态特性和完整性约束条件")]),v._v(" "),_("p",[v._v("数据模型三要素")]),v._v(" "),_("ol",[_("li",[v._v("数据结构")]),v._v(" "),_("li",[v._v("数据操纵")]),v._v(" "),_("li",[v._v("数据完整性约束")])]),v._v(" "),_("p",[v._v("按照模型应用的不同目的，数据模型可分为")]),v._v(" "),_("ul",[_("li",[v._v("概念模型：用于数据库设计")]),v._v(" "),_("li",[v._v("逻辑模型：数据库存储")]),v._v(" "),_("li",[v._v("物理模型：底层存储")])]),v._v(" "),_("img",{attrs:{src:s(554)}}),v._v(" "),_("h4",{attrs:{id:"概念模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#概念模型"}},[v._v("#")]),v._v(" 概念模型")]),v._v(" "),_("p",[v._v("常用的概念模型：E-R 图")]),v._v(" "),_("p",[v._v("联系的类型")]),v._v(" "),_("img",{attrs:{src:s(555)}}),v._v(" "),_("p",[v._v("完整的 E-R 图")]),v._v(" "),_("img",{attrs:{src:s(556)}}),v._v(" "),_("h4",{attrs:{id:"逻辑模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#逻辑模型"}},[v._v("#")]),v._v(" 逻辑模型")]),v._v(" "),_("p",[v._v("数据库领域常用的逻辑数据模型")]),v._v(" "),_("ol",[_("li",[v._v("层次模型")]),v._v(" "),_("li",[v._v("网状模型")]),v._v(" "),_("li",[v._v("关系模型")]),v._v(" "),_("li",[v._v("面向对象模型")]),v._v(" "),_("li",[v._v("对象关系模型")])]),v._v(" "),_("p",[v._v("层次模型示意图，每个节点的双亲是唯一的，多对多表示不自然")]),v._v(" "),_("img",{attrs:{src:s(557)}}),v._v(" "),_("p",[v._v("网状模型的实现")]),v._v(" "),_("ul",[_("li",[v._v("将多对多联系分解成两个一对多联系")]),v._v(" "),_("li",[v._v("对于带属性的联系单独作为一组记录")])]),v._v(" "),_("img",{attrs:{src:s(558)}}),v._v(" "),_("p",[v._v("结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于最终用户掌握")]),v._v(" "),_("p",[v._v("关系模型：关系型数据库所用的模型，就是 MySQL 这类数据库使用的逻辑模型")]),v._v(" "),_("img",{attrs:{src:s(559)}}),v._v(" "),_("p",[v._v("优点")]),v._v(" "),_("ul",[_("li",[v._v("建立在严格的数学概念的基础上")]),v._v(" "),_("li",[v._v("概念单一，数据结构简单、清晰，用户易懂易用\n"),_("ul",[_("li",[v._v("实体和各类联系都用关系来表示")]),v._v(" "),_("li",[v._v("对数据的检索结果也是关系")])])]),v._v(" "),_("li",[v._v("关系模型的存取路径对用户透明\n"),_("ul",[_("li",[v._v("具有更高的数据独立性，更好的安全保密性")]),v._v(" "),_("li",[v._v("简化了程序员的工作和数据库开发建立的工作")])])])]),v._v(" "),_("p",[v._v("缺点：存取路径对用户透明导致查询效率往往不如非关系数据模型，为提高性能，必须对用户的查询请求进行优化（例如索引），增加了开发数据库管理系统的难度")]),v._v(" "),_("h3",{attrs:{id:"关系型数据库内部架构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关系型数据库内部架构"}},[v._v("#")]),v._v(" 关系型数据库内部架构")]),v._v(" "),_("h4",{attrs:{id:"总体环境"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总体环境"}},[v._v("#")]),v._v(" 总体环境")]),v._v(" "),_("p",[v._v("C/S 模型")]),v._v(" "),_("img",{attrs:{src:s(560)}}),v._v(" "),_("p",[v._v("一般场景")]),v._v(" "),_("img",{attrs:{src:s(561)}}),v._v(" "),_("p",[v._v("进程模型和代理池")]),v._v(" "),_("img",{attrs:{src:s(562)}}),v._v(" "),_("p",[v._v("DBMS实例是一个可重入的系统：相同的代码副本由子进程/线程共享")]),v._v(" "),_("p",[v._v("DBMS系统通常带有“主”进程")]),v._v(" "),_("ul",[_("li",[v._v("维护一个“代理”池，每个代理本质上都是 DBMS 本身的副本")]),v._v(" "),_("li",[v._v("代理 = 进程模型（90年代早期）：每个 DB 代理都是一个子进程")]),v._v(" "),_("li",[v._v("代理 = 线程模型（90年代中期）：每个 DB 代理都是一个子线程")]),v._v(" "),_("li",[v._v("代理 = 协程模型（现在）：每个代理都是一个子协程\n"),_("ul",[_("li",[v._v("监听传入的连接请求")]),v._v(" "),_("li",[v._v("为新的连接请求分配一个可用的代理")]),v._v(" "),_("li",[v._v("为了自我保护，对收到的请求进行截流")]),v._v(" "),_("li",[v._v("在连接结束时，使代理退出执行，并存放到到代理池中")])])])]),v._v(" "),_("h4",{attrs:{id:"sql-引擎"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#sql-引擎"}},[v._v("#")]),v._v(" SQL 引擎")]),v._v(" "),_("p",[v._v("在刚刚的主从结构中，每个 DBMS 实例都由 SQL 引擎、存储引擎和持久性存储三个部分组成")]),v._v(" "),_("img",{attrs:{src:s(563)}}),v._v(" "),_("p",[v._v("SQL 引擎")]),v._v(" "),_("img",{attrs:{src:s(564)}}),v._v(" "),_("p",[v._v("其中")]),v._v(" "),_("ol",[_("li",[v._v("系统目录服务本质上是通过一些系统表来定义数据库内容的机制")]),v._v(" "),_("li",[v._v("编译器的功能是将一条SQL语句编译成执行计划")]),v._v(" "),_("li",[v._v("计划服务将程序文件进行预编译和包绑定")]),v._v(" "),_("li",[v._v("语句缓存服务保留之前SQL的编译结果（执行计划），从而避免重复编译同一条SQL语句")]),v._v(" "),_("li",[v._v("执行服务用来执行编译的结果，即执行计划")])]),v._v(" "),_("h4",{attrs:{id:"存储引擎"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#存储引擎"}},[v._v("#")]),v._v(" 存储引擎")]),v._v(" "),_("p",[v._v("存储引擎承接 SQL 引擎，管理整个系统的共享资源")]),v._v(" "),_("img",{attrs:{src:s(565)}}),v._v(" "),_("p",[v._v("一个典型的存储引擎包括六个子部件")]),v._v(" "),_("ul",[_("li",[v._v("数据服务：针对用户数据，提供高效的访问机制")]),v._v(" "),_("li",[v._v("索引服务：针对索引，提供高效的访问机制")]),v._v(" "),_("li",[v._v("序列化服务：管理共享资源，解决访问冲突")]),v._v(" "),_("li",[v._v("工具箱：包含管理共享资源的常用工具，如磁盘碎片整理工具等")]),v._v(" "),_("li",[v._v("数据缓存服务：起到桥梁作用，上述四个服务从缓存服务读取数据；同时，缓存服务将数据从底层存储加载到内存中")]),v._v(" "),_("li",[v._v("恢复服务：当数据库服务器发生宕机时，恢复服务对用户已经提交成功的数据进行恢复")])]),v._v(" "),_("h4",{attrs:{id:"垂直服务部件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垂直服务部件"}},[v._v("#")]),v._v(" 垂直服务部件")]),v._v(" "),_("p",[v._v("垂直服务部件通常横跨 SQL 引擎和存储引擎")]),v._v(" "),_("img",{attrs:{src:s(566)}}),v._v(" "),_("p",[v._v("他包括")]),v._v(" "),_("ul",[_("li",[v._v("事务服务\n"),_("ul",[_("li",[v._v("有关事务的管理，包括事务的开始、结束、写日志记录等")]),v._v(" "),_("li",[v._v("事务的开始和结束时在SQL引擎完成的，很多任务是在存储引擎完成的")])])]),v._v(" "),_("li",[v._v("仪器服务\n"),_("ul",[_("li",[v._v("数据库包含很多计数器，记录数据库运行的行为数据")]),v._v(" "),_("li",[v._v("例如增删改SQL语句的数量、缓存命中率等")]),v._v(" "),_("li",[v._v("这些行为数据即涉及SQL引擎，也涉及存储引擎")])])]),v._v(" "),_("li",[v._v("负载服务\n"),_("ul",[_("li",[v._v("数据库允许用户从业务出发来定义负载，设置不同事务（TP、批量作业和AP）的优先级")]),v._v(" "),_("li",[v._v("因此，需要赋予负载服务一定的权限来保证优先级的执行")])])])]),v._v(" "),_("h4",{attrs:{id:"多节点数据库"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多节点数据库"}},[v._v("#")]),v._v(" 多节点数据库")]),v._v(" "),_("p",[v._v("多节点服务器")]),v._v(" "),_("ul",[_("li",[v._v("数据存储在多个服务器，计算也可以在多个服务器上并发进行，可以满足高可扩展性和高可用性")]),v._v(" "),_("li",[v._v("集群架构：共享一切（share everything），即多节点之间共享数据库所有数据，每个节点能访问和处理数据库中所有数据")]),v._v(" "),_("li",[v._v("分布式架构：无共享（share nothing），数据库数据分布到不同节点，并且数据不能共享，但是元数据是共享的")])]),v._v(" "),_("p",[v._v("集群架构")]),v._v(" "),_("img",{attrs:{src:s(567)}}),v._v(" "),_("p",[v._v("耦合设施（处理全局结构） → 快速连接数据库节点")]),v._v(" "),_("p",[v._v("实现两级控制")]),v._v(" "),_("ul",[_("li",[v._v("全局级控制：进行跨节点的控制")]),v._v(" "),_("li",[v._v("节点级控制：与单节点数据库的控制一致")])]),v._v(" "),_("p",[v._v("结构")]),v._v(" "),_("ul",[_("li",[v._v("时钟：快速访问全局锁")]),v._v(" "),_("li",[v._v("序列化\n"),_("ol",[_("li",[v._v("任何数据从磁盘读到缓存，以及从缓存写到磁盘，都需要通过耦合设施；")]),v._v(" "),_("li",[v._v("进行数据更新时，需要使用锁机制：加锁前要先在耦合设施中注册，声明拥有某一页的副本及对该副本的意图；在没有其它节点对对该副本进行更新操作或仅有只读操作时，才能进行加锁；加锁以后，耦合设施使其它数据副本失效，从而保证数据一致性")]),v._v(" "),_("li",[v._v("对数据缓存、目录缓存和语句缓存等共享数据的访问，也需要进行序列化")])])]),v._v(" "),_("li",[v._v("日志：本地日志文件，日志合并")]),v._v(" "),_("li",[v._v("事务：全局事务 ID，全局日志记录序列号（log record sequence number, LRSN）")])]),v._v(" "),_("p",[v._v("高可用性（CAP 原则中的 A）：在任何情况下，特别是节点宕机、硬件升级维护和软件升级维护时，数据库系统都可以做到不关闭、相关业务和应用不中断")]),v._v(" "),_("ul",[_("li",[v._v("自动"),_("strong",[v._v("容灾机制")]),v._v(" "),_("ul",[_("li",[v._v("当出现节点失效时，系统可以通过共识协议来接管失效节点，使失效节点上未提交的事务失败")]),v._v(" "),_("li",[v._v("系统释放失效节点的主本节点角色，并为其上的主本数据分配新的主本节点")]),v._v(" "),_("li",[v._v("其余的DB节点共享其工作负载")])])]),v._v(" "),_("li",[v._v("硬件升级维护\n"),_("ul",[_("li",[v._v("加入/退出一个 DB 节点")]),v._v(" "),_("li",[v._v("重新为下线的数据分区分配主本节点")])])]),v._v(" "),_("li",[v._v("软件迁移维护\n"),_("ul",[_("li",[v._v("退出一个DB节点并迁移软件（例如：DB释放迁移）")]),v._v(" "),_("li",[v._v("加入这个DB节点并以“共存”模式运行在DB集群中")]),v._v(" "),_("li",[v._v("重复相同的过程，直到所有节点都成功迁移")])])])]),v._v(" "),_("p",[v._v("分布式架构（CAP 原则中的 P）")]),v._v(" "),_("img",{attrs:{src:s(568)}}),v._v(" "),_("p",[v._v("分布式协议")]),v._v(" "),_("ul",[_("li",[v._v("分布式数据库底层通过共识协议实现去中心化")]),v._v(" "),_("li",[v._v("分布式架构没有耦合设施的概念，它的每一个节点是对称的")])]),v._v(" "),_("p",[v._v("缺点")]),v._v(" "),_("ul",[_("li",[v._v("由于主副本的存在，在执行 SQL 语句时，主本节点多出了等待日志传输完成的动作")]),v._v(" "),_("li",[v._v("由于分布式存储，上层并不清楚数据的具体存放位置，在计算执行时，需要通过额外的计算来获取数据的存储位置")]),v._v(" "),_("li",[v._v("在执行时，可能要进行跨节点数据访问，而跨节点访问通过 TCP/IP 协议实现，因此效率很低")]),v._v(" "),_("li",[v._v("分布式数据库适用于互联网和物联网应用场景（高可扩展性、大量并发读操作、少量写操作），这与传统的数据库应用场景有很大差异")])]),v._v(" "),_("h2",{attrs:{id:"存储和索引技术"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#存储和索引技术"}},[v._v("#")]),v._v(" 存储和索引技术")]),v._v(" "),_("h3",{attrs:{id:"物理存储介质"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#物理存储介质"}},[v._v("#")]),v._v(" 物理存储介质")]),v._v(" "),_("img",{attrs:{src:s(569)}}),v._v(" "),_("p",[v._v("传统磁盘 HDD 的性能标准：访问时间、传输速率、磁盘块大小")]),v._v(" "),_("p",[v._v("顺序访问和随机访问")]),v._v(" "),_("img",{attrs:{src:s(570)}}),v._v(" "),_("h3",{attrs:{id:"面向磁盘的数据结构设计"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#面向磁盘的数据结构设计"}},[v._v("#")]),v._v(" 面向磁盘的数据结构设计")]),v._v(" "),_("blockquote",[_("p",[v._v("页间组织和页内存储")])]),v._v(" "),_("p",[v._v("页间组织结构：链表堆文件")]),v._v(" "),_("p",[v._v("业内存储")]),v._v(" "),_("p",[v._v("1️⃣ 面向元组的存储方式")]),v._v(" "),_("ul",[_("li",[v._v("定长元组存储")]),v._v(" "),_("li",[v._v("变长元组存储：分槽页面结构")]),v._v(" "),_("li",[v._v("超长元组存储")])]),v._v(" "),_("p",[v._v("2️⃣ 面向列的存储")]),v._v(" "),_("p",[v._v("行存并不是 DB 的标准，在特定类别的负载上不是最优的选择")]),v._v(" "),_("ul",[_("li",[v._v("OLTP：简单独写少量数据；通常只涉及一个或少量元组；点查询")]),v._v(" "),_("li",[v._v("OLAP：读取大量数据；涉及大量元组；通常周期性执行于 OLTP 应用形成的充足数据上")]),v._v(" "),_("li",[v._v("HTAP（OLTP + OLAP）")])]),v._v(" "),_("h3",{attrs:{id:"缓冲池"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓冲池"}},[v._v("#")]),v._v(" 缓冲池")]),v._v(" "),_("p",[v._v("什么是缓冲池")]),v._v(" "),_("ul",[_("li",[v._v("内存中的一部分空间")]),v._v(" "),_("li",[v._v("一系列相同大小 pages 构成的数组")]),v._v(" "),_("li",[v._v("数组元素—帧（frame）")])]),v._v(" "),_("img",{attrs:{src:s(571)}}),v._v(" "),_("p",[v._v("缓冲池的优化设计")]),v._v(" "),_("ul",[_("li",[v._v("多缓冲池")]),v._v(" "),_("li",[v._v("预取 Prefetching")]),v._v(" "),_("li",[v._v("共享游标")]),v._v(" "),_("li",[v._v("略过")]),v._v(" "),_("li",[v._v("OS 页面缓存")])]),v._v(" "),_("p",[v._v("缓存替换策略 / 页面替换算法")]),v._v(" "),_("ul",[_("li",[v._v("LRU 最久未使用")]),v._v(" "),_("li",[v._v("CLOCK 时钟置换")])]),v._v(" "),_("p",[v._v("一些缓存问题")]),v._v(" "),_("ol",[_("li",[v._v("顺序洪泛")]),v._v(" "),_("li",[v._v("锁（脏页面）")])]),v._v(" "),_("h3",{attrs:{id:"索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引"}},[v._v("#")]),v._v(" 索引")]),v._v(" "),_("p",[v._v("索引的设计目标")]),v._v(" "),_("ul",[_("li",[v._v("组织：如何在内存及页面中布局；存储什么信息以加速访问")]),v._v(" "),_("li",[v._v("并发：如何支持多线程的并发访问")])]),v._v(" "),_("p",[v._v("索引分类")]),v._v(" "),_("ul",[_("li",[v._v("聚簇索引（主索引）\n"),_("ul",[_("li",[v._v("搜索码还定义了文件的次序，即元组在文件中的存储按聚簇索引的搜索码顺序组织")]),v._v(" "),_("li",[v._v("聚簇索引的搜索码通常是主键，但也可以是其他属性（组）")])])]),v._v(" "),_("li",[v._v("非聚簇索引（辅助索引）"),_("strong",[v._v(":")]),v._v(" 其搜索码的顺序与文件内元组顺序不同")])]),v._v(" "),_("p",[v._v("索引顺序文件：按照某种搜索码顺序存储的文件")]),v._v(" "),_("ul",[_("li",[v._v("稠密索引")]),v._v(" "),_("li",[v._v("稀疏索引")])]),v._v(" "),_("p",[v._v("常见索引类型")]),v._v(" "),_("ul",[_("li",[v._v("顺序索引：搜索码按顺序组织")]),v._v(" "),_("li",[v._v("B+ 树索引：平衡树结构")]),v._v(" "),_("li",[v._v("哈希表索引：搜索码按照某个哈希函数平均分布到若干个桶中")])]),v._v(" "),_("p",[v._v("B+ 树索引")]),v._v(" "),_("img",{attrs:{src:s(572)}}),v._v(" "),_("p",[v._v("哈希表")]),v._v(" "),_("img",{attrs:{src:s(573)}}),v._v(" "),_("h2",{attrs:{id:"查询处理和优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#查询处理和优化"}},[v._v("#")]),v._v(" 查询处理和优化")]),v._v(" "),_("p",[v._v("SQL 引擎的工作：声明式的 SQL → 过程式的执行计划")]),v._v(" "),_("img",{attrs:{src:s(574)}}),v._v(" "),_("p",[v._v("整体流程")]),v._v(" "),_("img",{attrs:{src:s(575)}}),v._v(" "),_("h3",{attrs:{id:"查询解析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#查询解析"}},[v._v("#")]),v._v(" 查询解析")]),v._v(" "),_("p",[v._v("编译器（前两个黄色块）")]),v._v(" "),_("img",{attrs:{src:s(576)}}),v._v(" "),_("p",[v._v("第一颗抽象语法树")]),v._v(" "),_("img",{attrs:{src:s(577)}}),v._v(" "),_("p",[v._v("通过词法分析器 / 语法分析器进行构建（Flex / Bison）")]),v._v(" "),_("p",[v._v("自动生成的词法分析器（如 Lex）")]),v._v(" "),_("ul",[_("li",[v._v("使用正则表达式来定义元语言")]),v._v(" "),_("li",[v._v("Lex 将正则表达式作为输入，生成对应的词法分析器")])]),v._v(" "),_("p",[v._v("自动生成的语法分析器（如 Yacc）")]),v._v(" "),_("ul",[_("li",[v._v("使用元语言定义 SQL 的语法规则")]),v._v(" "),_("li",[v._v("Yacc 将语法规则作为输入，生成对应的语法分析器。该语法分析器实际上是一个下推自动机（pushdown automata），或带栈自动机（automata with a stack）")])]),v._v(" "),_("p",[v._v("语义处理的关键操作：移进（将字符标记放入栈中）和规约（用非终结符代替栈的顶部元素）")]),v._v(" "),_("p",[v._v("SQL 语言的词法规则示例（正则式）")]),v._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("ID    [a-z][a-z0-9]+ \nKeyword   select | from | where \nSEP  , | ; \nOP    = | + | < \nINT    [0-9]+ \n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br")])]),_("p",[v._v("语法分析器")]),v._v(" "),_("img",{attrs:{src:s(578)}}),v._v(" "),_("p",[v._v("SQL 语言的上下文无关语法示例")]),v._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("Rule 1： <SQL Statement> ::= <Select Statement> | <Insert Statement> | <Update Statement>\nRule 2：<SelectStatement> ::= SELECT <SelectList> FROM <FromList> WHERE <WhereClause>';'\nRule 3：<SelectList> ::= <SelectList>, <Name> | <Name> | '*'\nRule 4：<Name> ::= <ID> | <ID>.<ID>\nRule 5：<FromList> ::= <FromList>,<Name> | <Name>\nRule 6：<WhereClause> ::= <Condition>\nRule 7：<Condition> ::= <Name> <OP> <Value> | <Condition> AND <Condition>\nRule 8：<Value> ::= <INT> | <FLOAT> | <DOUBLE>\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br"),_("span",{staticClass:"line-number"},[v._v("6")]),_("br"),_("span",{staticClass:"line-number"},[v._v("7")]),_("br"),_("span",{staticClass:"line-number"},[v._v("8")]),_("br")])]),_("p",[v._v("语义检查 & 授权检查")]),v._v(" "),_("p",[v._v("语义检查是一个自底向上不断交替进行"),_("strong",[v._v("名称解析")]),v._v("、"),_("strong",[v._v("类型解析")]),v._v("、"),_("strong",[v._v("函数解析、类型匹配")]),v._v("并判断正误的过程")]),v._v(" "),_("p",[v._v("以"),_("code",[v._v("SELECT F(c1,3) FROM T WHERE c2>10;")]),v._v("为例")]),v._v(" "),_("img",{attrs:{src:s(579)}}),v._v(" "),_("ul",[_("li",[v._v("名称解析，例如 ① 函数名 F 和 ② 列名 c1")]),v._v(" "),_("li",[v._v("类型解析，例如确定 ② 列 c1 的数据类型")]),v._v(" "),_("li",[v._v("函数解析，例如 ④ 函数 F(c1,3)")]),v._v(" "),_("li",[v._v("类型匹配，包括类型转换和类型提升")])]),v._v(" "),_("p",[v._v("授权检查")]),v._v(" "),_("ul",[_("li",[v._v("授权ID")]),v._v(" "),_("li",[v._v("对象：表，视图，函数等")]),v._v(" "),_("li",[v._v("操作："),_("code",[v._v("SELECT, INSERT, DELETE, UPDATE, CREATE, DROP, ALTER")]),v._v("等等")]),v._v(" "),_("li",[v._v("特权：是/否")]),v._v(" "),_("li",[v._v("高级功能\n"),_("ul",[_("li",[v._v("受信任上下文")]),v._v(" "),_("li",[v._v("细粒度的访问控制(行级权限、列屏蔽等)")])])])]),v._v(" "),_("p",[v._v("在语义检查和授权检查后，构造了第二颗抽象语法树")]),v._v(" "),_("h3",{attrs:{id:"逻辑重写"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#逻辑重写"}},[v._v("#")]),v._v(" 逻辑重写")]),v._v(" "),_("p",[v._v("优化器")]),v._v(" "),_("h4",{attrs:{id:"基于规则的优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基于规则的优化"}},[v._v("#")]),v._v(" 基于规则的优化")]),v._v(" "),_("p",[v._v("基于规则的优化（Rule-based Optimization, RBO）")]),v._v(" "),_("ul",[_("li",[v._v("查询的逻辑重写，以尽可能减少不合理的开销")]),v._v(" "),_("li",[v._v("基于（关系代数的等价变换）规则")]),v._v(" "),_("li",[v._v("调整操作顺序")]),v._v(" "),_("li",[v._v("生成：由逻辑运算符组成的逻辑计划（树）\n"),_("ul",[_("li",[v._v("逻辑运算符：关系代数的算子（π，σ，⋈，…）")])])]),v._v(" "),_("li",[v._v("与关系实例无关")])]),v._v(" "),_("p",[v._v("关系代数的等价变换规则")]),v._v(" "),_("img",{attrs:{src:s(580)}}),v._v(" "),_("p",[v._v("本质上是基于关系代数的等价变换规则进行优化")]),v._v(" "),_("ul",[_("li",[v._v("初始逻辑计划 → 最优逻辑计划")]),v._v(" "),_("li",[v._v("提高最优（执行）计划被选择到的概率")]),v._v(" "),_("li",[v._v("实例无关")])]),v._v(" "),_("p",[v._v("RBO 通用规则")]),v._v(" "),_("ul",[_("li",[v._v("复合谓词拆分")]),v._v(" "),_("li",[v._v("谓词下推")]),v._v(" "),_("li",[v._v("笛卡尔积 → 连接")]),v._v(" "),_("li",[v._v("投影下推")])]),v._v(" "),_("p",[v._v("其他重写规则：嵌套查询、类似视图的处理、表达式重写")]),v._v(" "),_("h4",{attrs:{id:"基于代价的优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基于代价的优化"}},[v._v("#")]),v._v(" 基于代价的优化")]),v._v(" "),_("p",[v._v("基于代价的优化（Cost-based Optimization, CBO）")]),v._v(" "),_("ul",[_("li",[v._v("查询的物理优化")]),v._v(" "),_("li",[v._v("使用代价模型，对操作进行代价估计")]),v._v(" "),_("li",[v._v("衡量所有可能的执行方式，选择执行代价最小的")]),v._v(" "),_("li",[v._v("生成：由物理操作符组成的物理执行计划（树）\n"),_("ul",[_("li",[v._v("物理操作符：关系代数算子的具体物理实现 （1 → n 映射）")])])]),v._v(" "),_("li",[v._v("与关系实例相关：需要使用实例的统计信息")])]),v._v(" "),_("p",[v._v("一个 SQL 查询访问计划")]),v._v(" "),_("ul",[_("li",[v._v("访问方法：全表扫描、索引扫描、仅索引扫描（只访问索引键）")]),v._v(" "),_("li",[v._v("连接方法：查找连接、合并连接、哈希连接")]),v._v(" "),_("li",[v._v("访问路径：由于涉及到多表复合，表不同的访问顺序造成 NP-Hard 的访问路径问题")])]),v._v(" "),_("p",[v._v("基于"),_("strong",[v._v("统计信息")]),v._v("和"),_("strong",[v._v("开销模型")]),v._v("，利用动态规划算法对访问计划进行优化")]),v._v(" "),_("h3",{attrs:{id:"执行计划"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#执行计划"}},[v._v("#")]),v._v(" 执行计划")]),v._v(" "),_("p",[v._v("第三部分")]),v._v(" "),_("img",{attrs:{src:s(581)}}),v._v(" "),_("p",[v._v("获取 CBO 输出，包括")]),v._v(" "),_("ul",[_("li",[v._v("“最优”的物理计划")]),v._v(" "),_("li",[v._v("执行计划 QEP（Query Execution Plan）")]),v._v(" "),_("li",[v._v("算法区别 → 执行代价（cost）")])]),v._v(" "),_("p",[v._v("确定执行模型，给定 QEP，DBMS 执行的流程")]),v._v(" "),_("ul",[_("li",[v._v("QEP中每个物理操作符\n"),_("ul",[_("li",[v._v("对应一段具体代码实现")])])]),v._v(" "),_("li",[v._v("执行模型需要考虑如何从输入关系实例，结合QEP，串联各操作符的代码实现，以输出最终结果\n"),_("ul",[_("li",[v._v("物化模型：每一步物理操作符的中间结果物化（甚至落盘）后，用于下一步输入")]),v._v(" "),_("li",[v._v("火山模型 / 迭代模型：物理操作符的结果元组直接发送给下一个操作符使用（每个操作符需要实现一个Next()方法），中间不需物化")]),v._v(" "),_("li",[v._v("向量化模型：不是每次传递一个元组，而是每次一批\n以更好的利用现代CPU的SIMD指令")])])])]),v._v(" "),_("p",[v._v("三种执行模型")]),v._v(" "),_("ul",[_("li",[v._v("物化模型：每个操作符一次性读入所有输入（元组）；一次性输出所有（元组）")]),v._v(" "),_("li",[v._v("火山模型 / 管线化模型：每个操作符看成是迭代器\n"),_("ul",[_("li",[_("code",[v._v("Open(), Next(), Close()")])]),v._v(" "),_("li",[v._v("父节点 → 外层迭代")]),v._v(" "),_("li",[v._v("子节点 → 内层迭代")]),v._v(" "),_("li",[v._v("操作符（迭代层）间传递的是单个元组（投影）")]),v._v(" "),_("li",[v._v("随时产生随时迭代处理")])])]),v._v(" "),_("li",[v._v("向量化模型：同火山模型，每个操作符看成是迭代器，区别在于操作符（迭代层）间传递的\n"),_("ul",[_("li",[v._v("不是单个元组而是一批元组")]),v._v(" "),_("li",[v._v("攒够一批进行传递")]),v._v(" "),_("li",[v._v("最大化利用SIMD指令特性")])])])]),v._v(" "),_("p",[v._v("上述是常见的"),_("strong",[v._v("解释性执行器")]),v._v("，通过模型生成 CPU 指令，还有一类"),_("strong",[v._v("编译型执行器")]),v._v("，通过即时编译技术 JIT（Just-in-time Compilation）生成指令")]),v._v(" "),_("h2",{attrs:{id:"工业级存储引擎"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#工业级存储引擎"}},[v._v("#")]),v._v(" 工业级存储引擎")]),v._v(" "),_("p",[v._v("以开务数据库为例")]),v._v(" "),_("img",{attrs:{src:s(582)}}),v._v(" "),_("p",[v._v("KV Store")]),v._v(" "),_("ul",[_("li",[v._v("将关系数据转化为Key-Value（KV）数据")]),v._v(" "),_("li",[v._v("典型：RocksDB")])]),v._v(" "),_("p",[v._v("分布式存储")]),v._v(" "),_("ul",[_("li",[v._v("分布式 KV Store")]),v._v(" "),_("li",[v._v("高可用性：数据复制")]),v._v(" "),_("li",[v._v("一致性协议："),_("strong",[v._v("Raft")])])]),v._v(" "),_("p",[v._v("Raft 协议：Consul 和 Nacos 的 CP 模式使用的一致性协议")]),v._v(" "),_("h3",{attrs:{id:"关系的键值存储"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关系的键值存储"}},[v._v("#")]),v._v(" 关系的键值存储")]),v._v(" "),_("p",[v._v("以学生表为例，应该怎么用 KV 数据来表示这个表")]),v._v(" "),_("img",{attrs:{src:s(583)}}),v._v(" "),_("p",[v._v("一种表示方法：key 表示字段的完整路径，value 表示对应的值，如")]),v._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("(/student/Sname/95001, “李勇”) \n(/student/Ssex/95001, “男”)\n(/student/Sage/95001, “20”)\n(/student/Sdept/95001, “CS”) \n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br")])]),_("p",[v._v("或者用列簇表示，一个 key 对应多个值，每个值之间用空格分割")]),v._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("(/student/0/95001, “李勇 男”) \n(/student/1/95001, “20 CS”) \n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br")])]),_("p",[v._v("上面分别表示列簇"),_("code",[v._v("{Sname, Ssex}")]),v._v("和"),_("code",[v._v("{Sage, Sdept}")]),v._v("对应的"),_("code",[v._v("ID")])]),v._v(" "),_("p",[v._v("开务数据库的 KV 存储就是以列簇的方式，每个 Key 对应的 Value 由如下三部分组成")]),v._v(" "),_("ul",[_("li",[v._v("4个字节表示的整个KV对的校验和（checksum）")]),v._v(" "),_("li",[v._v("一个字节表示的值类型（value type）")]),v._v(" "),_("li",[v._v("对于的各个域的值拼接而成的字符串")])]),v._v(" "),_("p",[v._v("SQL 对应的 KV 插入操作如下")]),v._v(" "),_("div",{staticClass:"language-sql line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("INSERT")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("INTO")]),v._v(" student "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("VALUES")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("95005")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token string"}},[v._v("'孙涛'")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token string"}},[v._v("'男'")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("19")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token string"}},[v._v("'CS'")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br")])]),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v('put(/student/1/95005/0, "孙涛", "男")\nput(/student/1/95005/1, 19)\nput(/student/1/95005/2, "CS")\nput(/student/2/19/95005/0, 19, "孙涛")\nput(/student/2/19/95005/1, "CS")\n')])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br")])]),_("p",[v._v("可以注意到这里涉及到很多键值")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("1/sno/0")]),v._v("表示学号为 sno 的姓名、性别")]),v._v(" "),_("li",[_("code",[v._v("1/sno/1")]),v._v(" 表示学号为 sno 的年龄")]),v._v(" "),_("li",[_("code",[v._v("1/sno/2")]),v._v("表示学号为 sno 的专业")]),v._v(" "),_("li",[_("code",[v._v("2/age/sno/1")]),v._v("表示年龄为 age 学号为 sno 的专业")]),v._v(" "),_("li",[_("code",[v._v("2/age/sno/2")]),v._v("表示年龄为 age 学号为 sno 的年龄、性别")])]),v._v(" "),_("p",[v._v("这样设计是为了在分组查询时较快，比如查询年龄为 19 的学生年龄和性别，只需要限定键中"),_("code",[v._v("2/age/sno/1")]),v._v("中的"),_("code",[v._v("age")]),v._v("字段即可")]),v._v(" "),_("p",[v._v("相对应的删除操作")]),v._v(" "),_("div",{staticClass:"language-sql line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("DELETE")]),v._v(" FORM student "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("WHERE")]),v._v(" Sno"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("95001")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br")])]),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("delete(/student/1/95001/0)\ndelete(/student/1/95001/1)\ndelete(/student/1/95001/2)\ndelete(/student/2/19/95001/0)\ndelete(/student/2/19/95001/1)\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br")])]),_("p",[v._v("更新操作")]),v._v(" "),_("div",{staticClass:"language-sql line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("UPDATE")]),v._v(" student "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("SET")]),v._v(" Sdept"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"MA"')]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("WHERE")]),v._v(" Sno"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("95001")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br")])]),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("put(/student/1/95001/2, ‘MA’)\nput(/student/2/19/95001/1, ‘MA’)\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br")])]),_("p",[v._v("查询")]),v._v(" "),_("img",{attrs:{src:s(584)}}),v._v(" "),_("h3",{attrs:{id:"rocksdb"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rocksdb"}},[v._v("#")]),v._v(" RocksDB")]),v._v(" "),_("p",[v._v("架构")]),v._v(" "),_("ul",[_("li",[v._v("核心数据结构\n"),_("ul",[_("li",[v._v("MemTable → 一个在内存中的页面")]),v._v(" "),_("li",[v._v("SSTable → 一个页面")])])]),v._v(" "),_("li",[v._v("LSM 引擎："),_("code",[v._v("insert, delete, update, query and compactation")])])]),v._v(" "),_("img",{attrs:{src:s(585)}}),v._v(" "),_("p",[v._v("特点")]),v._v(" "),_("ul",[_("li",[v._v("一个可嵌入、高性能的 KV 开源数据库")]),v._v(" "),_("li",[v._v("由 Facebook 基于 levelDB 开发")]),v._v(" "),_("li",[v._v("为快速存储（SSD、RAM）而优化，延迟极小")]),v._v(" "),_("li",[v._v("大量灵活的配置，使之能针对不同的生产环境进行调优")]),v._v(" "),_("li",[v._v("完善的持久化机制，同时保证性能和安全性")]),v._v(" "),_("li",[v._v("RocksDB 使用 LSM 存储引擎，纯 C++编写")])]),v._v(" "),_("h4",{attrs:{id:"日志存储"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#日志存储"}},[v._v("#")]),v._v(" 日志存储")]),v._v(" "),_("p",[v._v("1️⃣ 写")]),v._v(" "),_("p",[v._v("DBMS 不断插入日志记录")]),v._v(" "),_("ul",[_("li",[v._v("日志记录包含对元组的改变（PUT、DEL）")]),v._v(" "),_("li",[v._v("日志记录包含元组的 ID")]),v._v(" "),_("li",[v._v("PUT 用来插入或修改一个记录")]),v._v(" "),_("li",[v._v("DEL 将某个记录标记为删除")])]),v._v(" "),_("p",[v._v("插入一条记录时，只需要将其附在文件末尾，无需修改之前的日志记录")]),v._v(" "),_("p",[v._v("当页面满了以后，DBMS 将该页面写入到磁盘上")]),v._v(" "),_("ul",[_("li",[v._v("顺序写入已满的页面")]),v._v(" "),_("li",[v._v("磁盘页面是不可修改的")])]),v._v(" "),_("p",[v._v("2️⃣ 读：访问给定 ID 对应的最新元组")]),v._v(" "),_("p",[v._v("方法一：顺序扫描，从最新的记录开始扫描，直到遇到该ID的第一个元组")]),v._v(" "),_("p",[v._v("方法二：建立 ID 上的索引")]),v._v(" "),_("ul",[_("li",[v._v("索引保存每个 ID 对应的最新记录的位置")]),v._v(" "),_("li",[v._v("根据索引，快速找到对应元组的位置")]),v._v(" "),_("li",[v._v("如果元组在内存中，直接读取")]),v._v(" "),_("li",[v._v("如果在磁盘上，读取它")])]),v._v(" "),_("p",[v._v("3️⃣ 数据压缩")]),v._v(" "),_("p",[v._v("一个页面被压缩以后，需要保持元组的时间顺序")]),v._v(" "),_("ul",[_("li",[v._v("保证每个元组 ID 只出现一次")]),v._v(" "),_("li",[v._v("系统会定期对数据进行压缩，来减少不必要的空间浪费")])]),v._v(" "),_("p",[v._v("DBMS 可以对一个页面内部的元组按照ID次序进行排序")]),v._v(" "),_("ul",[_("li",[v._v("有助于之后的快速检索")]),v._v(" "),_("li",[v._v("这种文件被称为 SSTables（Sorted String Tables）")])]),v._v(" "),_("h4",{attrs:{id:"数据结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[v._v("#")]),v._v(" 数据结构")]),v._v(" "),_("p",[v._v("SSTable 的特点")]),v._v(" "),_("ul",[_("li",[v._v("SSTable 是真正落地在磁盘上的文件")]),v._v(" "),_("li",[v._v("SSTable 中的数据都是按key有序排列的")]),v._v(" "),_("li",[v._v("SSTable 中存储的是大量的key-value")]),v._v(" "),_("li",[v._v("SSTable 是一个可以完成自解释的文件")])]),v._v(" "),_("p",[v._v("SSTable 文件布局")]),v._v(" "),_("ul",[_("li",[v._v("Data Block：存储数个有序的 key-value")]),v._v(" "),_("li",[v._v("Meta Block：存储 key-value 对应的 filter")]),v._v(" "),_("li",[v._v("MetaIndex Block：指向 Meta Block 的索引")]),v._v(" "),_("li",[v._v("Index Block：指向 Data Block 的索引")]),v._v(" "),_("li",[v._v("Footer：指向 MetaIndex Block 和 Index Block 的索引（索引的索引）")])]),v._v(" "),_("p",[v._v("MemTable的特点")]),v._v(" "),_("ul",[_("li",[v._v("MemTable 是存储在内存中的表，一般维护两个 MemTable\n"),_("ul",[_("li",[v._v("Active MemTable: 可写可读")]),v._v(" "),_("li",[v._v("Immutable MemTable：可读不可写")])])]),v._v(" "),_("li",[v._v("新写入的数据首先保存到 Active MemTable，当其 size 超过阈值（4KB），自动转化为 Immutable MemTable")]),v._v(" "),_("li",[v._v("RocksDB 将 Immutable MemTable 转换为 SSTable 保存到磁盘中")])]),v._v(" "),_("p",[v._v("MemTable 数据结构")]),v._v(" "),_("ul",[_("li",[v._v("使用 SkipList（跳表）来管理 KV 数据\n"),_("ul",[_("li",[v._v("跳表是 MemTable 的核心部分，本质是有序的链表")]),v._v(" "),_("li",[v._v("跳表中每个结点存储一个 KV 对")])])]),v._v(" "),_("li",[v._v("功能要求：插入、删除、修改和查询")])]),v._v(" "),_("h4",{attrs:{id:"跳表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#跳表"}},[v._v("#")]),v._v(" 跳表")]),v._v(" "),_("p",[v._v("完美的"),_("strong",[v._v("跳表")])]),v._v(" "),_("ul",[_("li",[v._v("键值有序排列")]),v._v(" "),_("li",[v._v("O(log n) 层")]),v._v(" "),_("li",[v._v("更高一层的元素数量是下一层的 1/2")]),v._v(" "),_("li",[v._v("节点的大小（size）不一，高层的节点有更多的指针，需要更多的空间来存储")])]),v._v(" "),_("p",[v._v("为什么选择跳表？")]),v._v(" "),_("p",[v._v("跳表 VS. 平衡树")]),v._v(" "),_("ul",[_("li",[v._v("点查询时，跳表和平衡树的时间复杂度都为 O(logn)，大体相当")]),v._v(" "),_("li",[v._v("范围查询时，平衡树操作更复杂，跳表只需找到最小值后再一层索引上遍历即可")]),v._v(" "),_("li",[v._v("平衡树上的插入和删除可能会引发子树的调整，逻辑复杂；而跳表的插入和删除只需修改相邻节点的指针")]),v._v(" "),_("li",[v._v("跳表的算法实现更简单")])]),v._v(" "),_("p",[v._v("跳表 VS. 哈希表：哈希表只能实现点查询，不适宜做范围查询")]),v._v(" "),_("p",[v._v("跳表 VS. 链表")]),v._v(" "),_("ul",[_("li",[v._v("链表的插入时间复杂度是 O(1)")]),v._v(" "),_("li",[v._v("链表的查询、删除和修改时间复杂度是 O(n)")])]),v._v(" "),_("h3",{attrs:{id:"新型数据库索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#新型数据库索引"}},[v._v("#")]),v._v(" 新型数据库索引")]),v._v(" "),_("p",[v._v("Learned Index，学习索引")]),v._v(" "),_("img",{attrs:{src:s(586)}}),v._v(" "),_("p",[v._v("RMI（recursive-model indexes）")]),v._v(" "),_("ul",[_("li",[v._v("[1] Kraska T, Beutel A, Chi E H, et al. The case for learned index structures[C]//Proceedings of the 2018 international conference on management of data. 2018: 489-504.")])]),v._v(" "),_("p",[v._v("最早的 learned index，中间节点中的模型为路由模型，叶子节点存放的是最终的预测模型")]),v._v(" "),_("img",{attrs:{src:s(587)}}),v._v(" "),_("p",[v._v("缺点：不能进行实时的写入（需要重新训练模型）；RMI 的训练成本和数据分布有很大关系")]),v._v(" "),_("p",[v._v("PGM（Piecewise Geometric Model index）")]),v._v(" "),_("ul",[_("li",[v._v("[2] Ferragina P, Vinciguerra G. The PGM-index: a fully-dynamic compressed learned index with provable worst-case bounds[J]. Proceedings of the VLDB Endowment, 2020, 13(8): 1162-1175.")])])])}),[],!1,null,null,null);_.default=a.exports},553:function(v,_,s){v.exports=s.p+"assets/img/image-20250514155457418.17c3fcdd.png"},554:function(v,_,s){v.exports=s.p+"assets/img/image-20250514155905786.77f971c0.png"},555:function(v,_,s){v.exports=s.p+"assets/img/image-20250514160945824.64d19c4e.png"},556:function(v,_,s){v.exports=s.p+"assets/img/image-20250514161043424.864b28aa.png"},557:function(v,_,s){v.exports=s.p+"assets/img/image-20250514162429569.e5134f8c.png"},558:function(v,_,s){v.exports=s.p+"assets/img/image-20250514162637360.b68257ef.png"},559:function(v,_,s){v.exports=s.p+"assets/img/image-20250514162846655.e1f82d88.png"},560:function(v,_,s){v.exports=s.p+"assets/img/image-20250514163152320.497e1553.png"},561:function(v,_,s){v.exports=s.p+"assets/img/image-20250514163257746.d081eb16.png"},562:function(v,_,s){v.exports=s.p+"assets/img/image-20250514163345792.0aa87218.png"},563:function(v,_,s){v.exports=s.p+"assets/img/image-20250514163646401.8247f89a.png"},564:function(v,_,s){v.exports=s.p+"assets/img/image-20250514163812657.dbb70fa4.png"},565:function(v,_,s){v.exports=s.p+"assets/img/image-20250514164306766.5c389676.png"},566:function(v,_,s){v.exports=s.p+"assets/img/image-20250514164401102.b3ea0a70.png"},567:function(v,_,s){v.exports=s.p+"assets/img/image-20250514164634338.aa5aac71.png"},568:function(v,_,s){v.exports=s.p+"assets/img/image-20250514164959812.467bd060.png"},569:function(v,_,s){v.exports=s.p+"assets/img/image-20250514165601762.18054d2b.png"},570:function(v,_,s){v.exports=s.p+"assets/img/image-20250514165734029.d0b4697b.png"},571:function(v,_,s){v.exports=s.p+"assets/img/image-20250514170531859.07c20f04.png"},572:function(v,_,s){v.exports=s.p+"assets/img/image-20250514171307735.f4b44a13.png"},573:function(v,_,s){v.exports=s.p+"assets/img/image-20250514171349853.80f80a64.png"},574:function(v,_,s){v.exports=s.p+"assets/img/image-20250516133252484.1c131001.png"},575:function(v,_,s){v.exports=s.p+"assets/img/image-20250516133401786.bbe36d6d.png"},576:function(v,_,s){v.exports=s.p+"assets/img/image-20250516140332557.0d591f62.png"},577:function(v,_,s){v.exports=s.p+"assets/img/image-20250516133512956.207a1030.png"},578:function(v,_,s){v.exports=s.p+"assets/img/image-20250516134045663.09db85f5.png"},579:function(v,_,s){v.exports=s.p+"assets/img/image-20250516134332225.ed2d8ce3.png"},580:function(v,_,s){v.exports=s.p+"assets/img/image-20250516135151540.6bc46776.png"},581:function(v,_,s){v.exports=s.p+"assets/img/image-20250516140241937.2a1c6697.png"},582:function(v,_,s){v.exports=s.p+"assets/img/image-20250514184508579.e671e814.png"},583:function(v,_,s){v.exports=s.p+"assets/img/image-20250516141048254.c53d12e5.png"},584:function(v,_,s){v.exports=s.p+"assets/img/image-20250516142625638.05f7eddd.png"},585:function(v,_,s){v.exports=s.p+"assets/img/image-20250516143329178.fb86d8aa.png"},586:function(v,_,s){v.exports=s.p+"assets/img/image-20250516144200306.a5e9ad8f.png"},587:function(v,_,s){v.exports=s.p+"assets/img/image-20250516144306611.202ca656.png"}}]);