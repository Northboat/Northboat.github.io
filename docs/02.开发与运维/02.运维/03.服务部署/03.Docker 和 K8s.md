---
date: 2025-5-19
permalink: /pages/b629cf/
title: Docker 和 K8s
author: 
  name: Northboat
  link: https://github.com/Northboat
---

## 镜像构建

### Dockerfile 多阶段构建

别忘记我们的核心诉求（或者说，容器的功能）

- 为应用程序提供运行环境
- 隔离运行在主机上不同进程

Dockerfile 定义了如何构建一个 Docker 镜像

```dockerfile
FROM golang:1.20
WORKDIR /app
COPY . .
RUN go build -o main .
CMD ["./main"]
```

这个 dockerfile

1. 使用官方`golang:1.20`镜像作为构建环境
2. 把所有文件复制到`/app`
3. 在容器内构建 Go 可执行文件`main`
4. 设置默认执行命令为`./main`

在本地执行以下命令来构建和运行镜像

```bash
docker build -t myapp . && docker run myapp
```

其中

| 部分           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| `docker build` | 表示你要构建一个 Docker 镜像                                 |
| `-t myapp`     | 给镜像起个名字（tag）叫 `myapp`，等同于 `--tag myapp`        |
| `.`            | 表示根据**当前目录**构建上下文（会将此目录的文件发送给 Docker 引擎使用） |

即：在当前目录下查找`Dockerfile`，然后构建一个镜像，并命名为`myapp`

这样的构建是有问题的：使用了 **构建 + 运行**混合的镜像（未分阶段）

1. `golang:1.20` 镜像很大（约 1GB+），包含编译器、工具链，不适合运行时部署
2. 生成的镜像包含了源代码和构建缓存，不干净、不安全

就是说，如果像上述做法打包，将一次性将 Go 源码、编译工具链（Go Build）、编译缓存和可执行文件都打包，构建后镜像至少高达 800MB+，这对于部署、安全、传输都很不妙

正确的做法是多阶段构建（Multi-stage build）

- 多阶段构建是一种在一个 Dockerfile 中使用多个`FROM`段落，**用前面的镜像构建产物**，最后用一个**干净的基础镜像**打包最终产物，从而实现“构建和运行分离”

多阶段构建：只打包“最终产物”

- 它的核心思想：**用一个镜像“编译”，再用另一个镜像“运行”**

例如

```dockerfile
# === 第一阶段：构建镜像（builder）
FROM golang:1.20 AS builder
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o main .

# === 第二阶段：运行镜像（干净、最小）
FROM alpine:latest
WORKDIR /root/
COPY --from=builder /app/main .

CMD ["./main"]
```

第一阶段：构建产物

```dockerfile
FROM golang:1.20 AS builder
```

- 用官方带编译器的 Golang 镜像构建可执行文件
- `AS builder`给这个阶段命个名字，后面可以引用

```dockerfile
go.mod go.sum ./ && RUN go mod download
COPY . . && RUN go build -o main .
```

这是 go 项目的常规构建过程

第二阶段：最小运行时镜像

```dockerfile
FROM alpine:latest
```

- 超小镜像（仅 5MB 左右）
- 不含 Go 编译器，不含源码，不含构建缓存 —— 非常安全干净

```dockerfile
COPY --from=builder /app/main .
```

- 仅把前面构建出的可执行文件 `main` 复制过来，其它统统不要

这样将获得一个 20MB 左右的运行镜像，用于生产部署，而构建镜像作为临时产物将被丢弃掉，不参与最后的部署

| 优点         | 描述                                       |
| ------------ | ------------------------------------------ |
| ✅ 更小的镜像 | 只包含运行必需文件                         |
| ✅ 更安全     | 去除了构建工具、源码等敏感内容             |
| ✅ 更快部署   | 镜像传输快，容器启动快                     |
| ✅ 适合 CI/CD | 用`docker build`一次构建，产出即部署级镜像 |

在当前目录下测试构建运行

```bash
docker build -t myMultiApp .
docker run --rm myMkultiApp
```

简单来说：多阶段构建 = 构建与运行分离，使用“胖”镜像编译代码，用“瘦”镜像跑服务

### Spring 应用容器化

以一个简单的Spring Boot Web应用程序为例，包含以下特点

- Spring Boot 3
- Java 17
- Maven 构建工具
- RESTful API 接口
- 标准的项目结构

项目结构如下

```
|——src/
|	|—— main/
|	|	|—— java/
|	|	|	|__ cia/arkrypto/demoapp/
|	|	|__ resources/
|	|__ test/
|—— pom.xml
|—— Dockerfile
|__ kubernetes/
	|—— deployment.yaml
	|—— service.yaml
	|__ ingress.yaml
```

验证本地环境

```sh
java -version
mvn -version
docker --version
kubectl version
```

容器化 Spring 应用：我们需要创建一个 Dockerfile 来构建应用容器，使用多阶段构建来优化最终镜像大小

```dockerfile
# 第一阶段：构建应用
FROM maven:3.8-openjdk-17 AS build
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline -BCOPY src ./srcRUN mvn package -DskipTests

# 第二阶段：运行应用
FROM openjdk:17-jre-slim
WORKDIR /app
COPY --from=build /app/target/demoapp-0.1.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
```

和上面多阶段部署的样例一样，这个 Dockerfile 包含两个阶段

- 构建阶段：使用 Maven 构建应用
- 运行阶段：使用精简版 JRE 运行应用

构建并测试 Docker 镜像

```sh
# 构建镜像
docker build -t demoapp:latest .
# 测试运行
docker run -p 8080:8080 demoapp:latest
```

OK，这样就好了，当启动镜像后，就可以在本地的 8080 端口访问这个 Spring 应用

- 进一步的，如果有配套的 CI 工具（比如说 Jenkins），就可以将这个镜像 demoapp 推送到对应的服务器上并执行容器启动命令`docker run`，就完成了一次全自动的打包和部署

### Docker-Compose 编排

Docker-Compose：定义多个 Docker 容器的运行方式

docker-compose.yaml

```yaml
version: '3'
services:
  app:
    build: .
    ports:
      - "8080:8080"
    depends_on:
      - db
  db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: 123456
```

上述 docker-compose 包含两个服务

- `app`: 用当前目录构建的应用容器
- `db`: 使用 MySQL 8.0 镜像的数据库容器

各字段含义

| 字段               | 说明                                                       |
| ------------------ | ---------------------------------------------------------- |
| `version: '3'`     | 指定 compose 文件版本（v3 通常用于 Docker Engine + Swarm） |
| `services`         | 定义所有容器服务                                           |
| `app.build: .`     | 当前目录构建（寻找`Dockerfile`）                           |
| `ports: 8080:8080` | 本地 8080 映射到容器 8080                                  |
| `depends_on`       | 让`app`在`db`之后启动（注意：不是等待 DB 可用，仅顺序）    |
| `db.image`         | 使用官方 MySQL 8.0 镜像                                    |
| `db.environment`   | 设置 root 用户密码为`example`                              |

在含有`Dockerfile`和`docker-compose.yml`的目录运行

```sh
docker-compose up --build -d
```

- `docker-compose`: 使用 Docker Compose 工具（多容器编排）
- `up`: 表示启动所有服务
- `--build`: 表示在启动前先强制重新构建服务镜像
- `-d`：表示后台运行

Docker 将

1. 解析 compose 文件
2. 找到 Dockerfile 构建 APP 镜像
3. 拉取远程镜像（MySQL 8.0）
4. 创建网络
5. 创建并启动容器
6. 日志输出并后台运行

注意

`--build`将会强制重新构建、拉取镜像，如果不加，默认**不会**重新构建镜像，会直接用上次构建好的本地镜像（只要镜像没删掉，Docker Compose 会复用它）

- 这是 Docker 的“增量构建”和“缓存重用”机制

当命令没有加上`-d`时，将默认为前台运行，即按下 ctrl c 后，将发送`SIGINT`给所有容器并关闭

查看当前容器组状态

```sh
docker-compose ps
```

停止后台的容器组

```bash
docker-compose down
```

这会停止并移除容器、网络、默认卷（但不会删除镜像）

如需彻底删除

```bash
docker-compose down --volumes --rmi all
```

## 容器逃逸

“容器逃逸”（Container Escape）是容器安全中非常核心、也非常危险的一个概念，一句话来说：容器逃逸指攻击者通过某种方式，从容器内部突破隔离机制，进入或控制宿主机（Host OS），进而可能影响其他容器或整个系统

容器逃逸的典型方式

1️⃣ 内核漏洞

- 容器和宿主机共用 Linux 内核，如果容器里运行的程序触发了内核漏洞，就可能直接提权
- 例子：CVE-2022-0185、Dirty Pipe（CVE-2022-0847）、Dirty Cow（CVE-2016-5195）

2️⃣ 特权容器（Privileged Container）

- 如果容器被配置成 `--privileged` 模式，它几乎拥有宿主机上的所有能力，非常危险
- 如果攻击者控制了这种容器，可以访问设备节点、修改内核模块等，轻松逃逸

3️⃣ 挂载宿主机目录：

- 如果宿主机的敏感路径（如 `/etc`、`/var/run/docker.sock`）被挂载到容器中，容器内的进程可以直接控制宿主机

4️⃣ 容器运行时漏洞（如 Docker、containerd）

- 如果容器运行时本身有漏洞，攻击者可以利用这些缺陷突破隔离
- 例如：runc 早期版本有直接实现容器逃逸的漏洞

逃逸的后果

| 后果          | 说明                           |
| ------------- | ------------------------------ |
| 访问主机系统  | 攻击者可读取主机文件、用户信息 |
| 横向移动      | 攻击者可攻击其他容器或服务     |
| 控制宿主网络  | 劫持流量，监控通信             |
| 安装后门      | 实现持续性控制（APT）          |
| 删除/加密数据 | 类似勒索软件行为               |

如何防止容器逃逸

| 防御手段                     | 说明                                                |
| ---------------------------- | --------------------------------------------------- |
| ✅ 使用最小权限原则           | 不使用 `--privileged`，只赋予必要的 `capabilities`  |
| ✅ 不挂载敏感主机路径         | 如 `/var/run/docker.sock`、`/etc`                   |
| ✅ 运行非 root 用户           | 尽量使用非 root 账户运行容器                        |
| ✅ 使用内核安全模块           | 如 AppArmor、SELinux、Seccomp，限制系统调用         |
| ✅ 隔离运行时                 | 用 gVisor、Kata Containers 等沙箱运行技术增强隔离性 |
| ✅ 定期更新内核与 Docker 版本 | 修复已知漏洞                                        |
| ✅ 使用容器扫描工具           | 如 Trivy、Aqua、Sysdig 识别潜在风险                 |

容器逃逸 = 容器“突破封锁”访问主机系统，是一种非常严重的安全风险，尤其是在多租户平台（如 Kubernetes 集群）中

- 部署生产容器时，安全配置必须严格审查

## K8s 基础

Kubernetes 是用于自动部署、扩展和容器化应用程序的开源系统

### K8s 概述

我们回顾一下，Docker 的三个主要概念和核心目的

- 三个概念：容器（运行在虚拟机上的进程）、镜像（容器的”源码“）、仓库（镜像库）
- 核心目的：为应用程序提供运行环境，并隔离运行在主机上不同进程

当使用的容器服务多了，面临的访问量增大以后，或者是在分布式架构下涉及到复杂的相互调用，容器间的编排显得尤为重要，错误的编排调用策略将导致一片混乱

于是我们需要一种工具把这些容器统一的管理起来，需要实现对这些个容器的自动部署、扩展和管理，也就是所谓的容器编排，K8s 正是这样一个自动化容器编排的系统

其优点如下

- 可移植性、灵活性和可扩展性
- 支持命令式/声明式配置和自动化
- CNCF 的一个毕业项目，生态系统庞大

### K3s 部署监控

K3s 是 Rancher 实验室的一个轻量级 Kubernetes 发行版，是由 CNCF 完全认证的 Kubernetes 产品，适合在资源受限的硬件上使用（例如 IoT 设备），它保留了 Kubernetes 的核心功能，但通过去除一些不必要的组件（如云服务提供商集成）来减小二进制文件的大小（K3s 的基础二进制包大小不到 100MB）

需要注意的是轻量级带来的功能缺失，如

- K3s 目前不支持在主节点上运行除 SQLite 以外的任何其他数据库
- 不支持多个主节点

故而在选择默认容器编排器时，定义需求和目标非常重要

部署监控流程

1. 容器化：使用`Docker`构建 Spring 微服务；使用`Helm`部署微服务
3. K3s 基础：安装 K3s，创建 Deployment、Service、Ingress
3. 应用部署：依次 apply deployment、service、ingress，并进行部署验证 kubectl get
3. 验证和测试：检查应用状态、访问应用
3. 服务监控：Prometheus + Grafana 进行监控，Loki + Promtail 进行日志采集

快速安装

```sh
curl -sfL https://get.k3s.io | sh -
# 检查就绪代码
takes maybe 30 seconds
k3s kubectl get node
```

三个配置文件

- deployment.yaml
- service.yaml
- ingress.yaml

常见问题及解决方案

Pod 启动失败

```sh
kubectl describe pod <pod-name>
kubectl logs <pod-name>
```

服务无法访问

```sh
kubectl get endpoints demoapp
kubectl describe service demoapp
```

Ingress 问题

```sh
kubectl describe ingress demoapp
kubectl get events
```
