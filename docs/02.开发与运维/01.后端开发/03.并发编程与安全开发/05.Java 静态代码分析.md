---
title: Java 静态代码分析
date: 2025-6-19
permalink: /pages/aecc6a/
author: 
  name: Arkrypto
  link: https://github.com/Arkrypto
---

## 静态代码分析概述

### 什么是 SCA

静态代码分析（Static Code Analysis），是指在不运行程序的前提下，对源代码或中间代码（如字节码）进行分析，以发现潜在的问题、缺陷、漏洞或优化点

检查范围

| 检查维度       | 示例                                             |
| -------------- | ------------------------------------------------ |
| ✅ 语法错误     | 拼写错误、漏掉分号、类型不匹配                   |
| ⚠️ 代码规范     | 命名不规范、缩进不统一、行过长                   |
| 🐛 潜在 bug     | 空指针、数组越界、死代码、未关闭资源             |
| 🔐 安全漏洞     | SQL 注入、XSS、路径遍历、硬编码密码              |
| 🧊 性能问题     | 重复计算、不必要对象创建                         |
| 🔧 可维护性问题 | 高复杂度、过深嵌套、长方法、循环依赖             |
| 🎯 设计层面     | 依赖反转、违反 SRP/OCP、代码坏味道（code smell） |

常见的静态分析工具

| 语言       | 工具                                                | 简介                                           |
| ---------- | --------------------------------------------------- | ---------------------------------------------- |
| Java       | ✅ [SonarQube](https://www.sonarqube.org/)           | 全面代码质量平台（支持 Web 展示）              |
| Java       | [SpotBugs（FindBugs）](https://spotbugs.github.io/) | 检查字节码，发现 bug 模式                      |
| Java       | PMD                                                 | 检查代码规范、冗余代码                         |
| Java       | Checkstyle                                          | 检查命名、格式、注释规范等                     |
| Python     | pylint / flake8 / mypy                              | 语法检查 + 类型检查                            |
| JavaScript | ESLint                                              | 最广泛使用的前端代码静态分析                   |
| C/C++      | cppcheck / clang-tidy / Coverity                    | 安全漏洞、内存错误分析                         |
| 多语言     | [Semgrep](https://semgrep.dev/)                     | 支持模式匹配式安全规则，可自定义               |
| 多语言     | CodeQL（GitHub）                                    | 类似 SQL 的代码查询语言，GitHub Actions 可集成 |

### 常见场景

在 CI/CD 流程中进行代码审查，例如使用 GitHub、GitLab、Jenkins，将分析工具**集成进你的代码提交或 PR 流程中**，让每次 push 都自动检查代码质量和安全性

安全扫描类库

- SonarQube 安全规则集
- Semgrep 安全规则库
- CodeQL：GitHub 官方推荐，用于查找逻辑型安全问题（如访问控制缺失、注入漏洞）

集成 SonarQube

- 在本地或 CI/CD 中部署 SonarQube Server
- 使用 `sonar-scanner` 或 Maven 插件上传代码分析结果
- 可通过浏览器查看：bugs、code smells、安全漏洞、重复代码等

或者在开发过程中使用插件进行代码检查

| 工具       | 集成方式                                |
| ---------- | --------------------------------------- |
| Checkstyle | IDE 插件或 Maven 插件（自动 fail 构建） |
| SpotBugs   | Maven 插件 / Gradle 插件                |
| PMD        | IDE 插件或`mvn pmd:check`               |

### 分析的底层逻辑

静态分析的底层，其实就像编译器的前端（语法分析 ➜ 抽象语法树 ➜ 语义检查 ➜ 流程分析）

```
源代码
  ↓
词法分析（Lexer）
  ↓
语法分析（Parser）→ 抽象语法树 AST
  ↓
语义分析（类型推断、符号绑定）
  ↓
控制流分析（CFA）& 数据流分析（DFA）
  ↓
规则匹配（Lint）或模式匹配（如 Semgrep、CodeQL）
  ↓
输出警告 / 错误 / 报告
```

1️⃣ 词法分析（Lexical Analysis）

把源码分割成一串 token（关键词、标识符、括号、分号等），例如

```java
int x = 5;
```

会被分割成：`int`, `x`, `=`, `5`, `;`

2️⃣ 语法分析（Syntax Analysis）

- 基于上下文无关文法（CFG），将 token 结构化成抽象语法树（AST）
- AST 是“源代码的结构表示”，也是大部分静态分析的核心入口

例如代码：`if (x > 0) y = 1;`）

```java
IfStatement
 ├─ Condition: BinaryExpr (x > 0)
 └─ Then: AssignExpr (y = 1)
```

工具如 ESLint、Checkstyle、PMD、SpotBugs 都会用 AST

3️⃣ 语义分析（Semantic Analysis）

检查变量类型、作用域、是否定义、调用合法性等，例如

```java
x = y + 1;  // 如果 y 没有定义，报错
```

4️⃣ 控制流分析（Control Flow Analysis, CFA）

- 构建控制流程图（CFG），分析条件/循环/分支/跳转
- 用来判断代码是否可达、分支覆盖是否完整等

图示

```css
[Start]
   ↓
[x > 0] ─Yes→ [doSomething()]
     └─No─→ [return]
```

5️⃣ 数据流分析（Data Flow Analysis, DFA）

- 分析变量的定义-使用链、是否初始化、是否为空等
- 举例：空指针分析、资源未关闭、变量未赋值就使用等，SpotBugs 等工具广泛应用

6️⃣ 规则匹配 / 模式识别（Pattern Matching）

- 使用预定义或用户自定义的规则集来匹配代码结构
- 如 Checkstyle 会检查 `class 命名必须大写开头`，PMD 会匹配 `== null` 的代码块
- Semgrep/CodeQL 更强，它可以匹配结构+上下文

```yaml
rules:
  - id: detect-hardcoded-password
    pattern: |
      password = "..."
```

模式匹配 + AST 导航是现代分析工具（如 Semgrep、CodeQL）的重要特性

### 更智能的方法

| 方法                                | 说明                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| 符号执行（Symbolic Execution）      | 把变量当成符号而不是具体值进行逻辑推演，用于路径覆盖         |
| 抽象解释（Abstract Interpretation） | 对程序执行进行近似建模，保守地发现问题                       |
| 模型检测（Model Checking）          | 建模程序状态机，验证其是否满足规范（如死锁）                 |
| 人工智能辅助分析                    | 结合语言模型，自动修复警告或生成规则（GitHub Copilot + CodeQL） |

## Java API 分析

考虑这样一个场景：对于一个完整的 Spring 项目，我需要按照接口，抽丝剥茧般把每个 API 的底层调用整理成一个完整的依赖链路，而后将这个链路包括相关的源码扔给大模型进行安全性分析

问题的关键在于，如何构建这条 API 调用的依赖路径